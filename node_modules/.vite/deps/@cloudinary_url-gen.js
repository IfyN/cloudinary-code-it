import {
  LayerAction,
  Overlay,
  createGravityFromModel,
  createSourceFromModel
} from "./chunk-YGR7YA3C.js";
import "./chunk-FFLRY66Z.js";
import {
  AspectRatioQualifierValue,
  Background,
  BackgroundAutoBorderQualifier,
  BackgroundAutoPredominantQualifier,
  BackgroundBorderGradientQualifier,
  BackgroundGenerativeFillQualifier,
  BackgroundPredominantGradientQualifier,
  BlurredBackgroundAction_default,
  ColorSpace,
  CustomRegion,
  DEFAULT_BRIGHTNESS,
  DEFAULT_INTENSITY,
  RectangleRegion,
  auto,
  border,
  borderGradient,
  color,
  custom,
  encodePromptComponent,
  faces,
  generativeFill,
  ocr,
  predominant,
  predominantGradient,
  qualifiers_exports
} from "./chunk-KG5TRSVR.js";
import "./chunk-UOU56KAB.js";
import {
  ACTION_TYPE_TO_CROP_MODE_MAP,
  ACTION_TYPE_TO_EFFECT_MODE_MAP,
  ACTION_TYPE_TO_QUALITY_MODE_MAP,
  ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP,
  CHROMA_MODEL_ENUM_TO_CHROMA_VALUE,
  CHROMA_VALUE_TO_CHROMA_MODEL_ENUM,
  COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP,
  COLOR_SPACE_MODE_TO_COLOR_SPACE_MODEL_MODE_MAP,
  CROP_MODE_TO_ACTION_TYPE_MAP,
  DELIVERY_MODE_TO_ACTION_TYPE_MAP,
  EFFECT_MODE_TO_ACTION_TYPE_MAP,
  STREAMING_PROFILE_TO_ACTION_TYPE_MAP,
  animated,
  animatedWebP,
  clip,
  clipEvenOdd,
  createGravityModel,
  ignoreInitialAspectRatio,
  lossy,
  preserveTransparency,
  progressive,
  regionRelative,
  relative
} from "./chunk-D77YR4MJ.js";
import {
  GravityQualifier
} from "./chunk-4C5QNDBA.js";
import "./chunk-HUOJ2QBX.js";
import {
  Action,
  FlagQualifier,
  FormatQualifier,
  VideoSource,
  base64Encode,
  prepareColor
} from "./chunk-IJ5XSMUJ.js";
import {
  Qualifier
} from "./chunk-5XSOESE5.js";
import "./chunk-5OEFRWJG.js";
import {
  createUnsupportedError
} from "./chunk-A6YZDHPZ.js";
import {
  QualifierValue
} from "./chunk-QESUYXYX.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/@cloudinary/url-gen/config/BaseConfig.js
function isObject(a) {
  if (typeof a !== "object" || a instanceof Array) {
    return false;
  } else {
    return true;
  }
}
var Config = class {
  filterOutNonSupportedKeys(userProvidedConfig, validKeys) {
    const obj = /* @__PURE__ */ Object.create({});
    if (isObject(userProvidedConfig)) {
      Object.keys(userProvidedConfig).forEach((key) => {
        if (validKeys.indexOf(key) >= 0) {
          obj[key] = userProvidedConfig[key];
        } else {
          console.warn("Warning - unsupported key provided to configuration: ", key);
        }
      });
      return obj;
    } else {
      return /* @__PURE__ */ Object.create({});
    }
  }
};
var BaseConfig_default = Config;

// node_modules/@cloudinary/url-gen/internal/internalConstants.js
var ALLOWED_URL_CONFIG = [
  "cname",
  "secureDistribution",
  "privateCdn",
  "signUrl",
  "longUrlSignature",
  "shorten",
  "useRootPath",
  "secure",
  "forceVersion",
  "analytics",
  "queryParams"
];
var ALLOWED_CLOUD_CONFIG = [
  "cloudName",
  "apiKey",
  "apiSecret",
  "authToken"
];

// node_modules/@cloudinary/url-gen/config/URLConfig.js
var URLConfig = class _URLConfig extends BaseConfig_default {
  /**
   * @param {IURLConfig} userURLConfig
   */
  constructor(userURLConfig) {
    super();
    const urlConfig = this.filterOutNonSupportedKeys(userURLConfig, ALLOWED_URL_CONFIG);
    Object.assign(this, {
      secure: true
    }, urlConfig);
  }
  extend(userURLConfig) {
    const urlConfig = this.filterOutNonSupportedKeys(userURLConfig, ALLOWED_URL_CONFIG);
    return new _URLConfig(Object.assign({}, this, urlConfig));
  }
  /**
   * @param {string} value Sets the cname
   */
  setCname(value) {
    this.cname = value;
    return this;
  }
  /**
   * @param {string} value Sets the secureDistribution
   */
  setSecureDistribution(value) {
    this.secureDistribution = value;
    return this;
  }
  /**
   * @param {boolean} value Sets whether to use a private CDN (Removes cloudName from URL)
   */
  setPrivateCdn(value) {
    this.privateCdn = value;
    return this;
  }
  /**
   * @param value Sets whether or not to sign the URL
   */
  setSignUrl(value) {
    this.signUrl = value;
    return this;
  }
  /**
   * @param value Sets whether or not to use a long signature
   */
  setLongUrlSignature(value) {
    this.longUrlSignature = value;
    return this;
  }
  /**
   * @param value Sets whether or not to shorten the URL
   */
  setShorten(value) {
    this.shorten = value;
    return this;
  }
  /**
   * @param value Sets whether or not to use a root path
   */
  setUseRootPath(value) {
    this.useRootPath = value;
    return this;
  }
  /**
   * @param value Sets whether or not to deliver the asset through https
   */
  setSecure(value) {
    this.secure = value;
    return this;
  }
  /**
   * @param value Sets whether to force a version in the URL
   */
  setForceVersion(value) {
    this.forceVersion = value;
    return this;
  }
  /**
   * @param params Sets additional params
   */
  setQueryParams(params) {
    this.queryParams = params;
    return this;
  }
};
var URLConfig_default = URLConfig;

// node_modules/@cloudinary/url-gen/config/CloudConfig.js
var CloudConfig = class _CloudConfig extends BaseConfig_default {
  /**
   * @param {ICloudConfig} userCloudConfig {@link ICloudConfig}
   *
   */
  constructor(userCloudConfig) {
    super();
    const cloudConfig = this.filterOutNonSupportedKeys(userCloudConfig, ALLOWED_CLOUD_CONFIG);
    Object.assign(this, cloudConfig);
    if (!this.cloudName) {
      throw "Missing mandatory field cloudName";
    }
  }
  extend(userCloudConfig) {
    const cloudConfig = this.filterOutNonSupportedKeys(userCloudConfig, ALLOWED_CLOUD_CONFIG);
    return new _CloudConfig(Object.assign({}, this, cloudConfig));
  }
  /**
   * @param {string} value Sets the CloudName
   */
  setCloudName(value) {
    this.cloudName = value;
    return this;
  }
  /**
   * @param {string} value Sets the API Key
   */
  setApiKey(value) {
    this.apiKey = value;
    return this;
  }
  /**
   * @param {string} value Sets the API Secret
   */
  setApiSecret(value) {
    this.apiSecret = value;
    return this;
  }
};
var CloudConfig_default = CloudConfig;

// node_modules/@cloudinary/url-gen/config/CloudinaryConfig.js
var CloudinaryConfig = class {
  constructor(configurations = {}) {
    this.cloud = new CloudConfig_default(configurations.cloud);
    this.url = new URLConfig_default(configurations.url || {});
  }
  /**
   * @description Setter for the cloudConfig
   * @param {ICloudConfig} cld
   */
  setCloudConfig(cld) {
    this.cloud = new CloudConfig_default(cld);
    return this;
  }
  /**
   * @description Setter for the urlConfig
   * @param {IURLConfig} url
   */
  setURLConfig(url) {
    this.url = new URLConfig_default(url);
    return this;
  }
  extend(configurations) {
    this.cloud = this.cloud.extend(configurations.cloud || {});
    this.url = this.url.extend(configurations.url || {});
    return this;
  }
};
var CloudinaryConfig_default = CloudinaryConfig;

// node_modules/@cloudinary/transformation-builder-sdk/actions/background/actions/BackgroundColor.js
var BackgroundColor = class extends Action {
  constructor(color2) {
    super();
    this._actionModel = {};
    this.addQualifier(new Qualifier("b", new QualifierValue(prepareColor(color2)).setDelimiter("_")));
    this._actionModel.color = color2;
    this._actionModel.actionType = "backgroundColor";
  }
  static fromJson(actionModel) {
    const { color: color2 } = actionModel;
    const result = new this(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/RawAction.js
var RawAction = class {
  constructor(raw) {
    this.raw = raw;
  }
  toString() {
    return this.raw;
  }
  toJson() {
    return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IErrorObject.js
function isErrorObject(obj) {
  const errorObj = obj;
  return "error" in errorObj && !!errorObj.error;
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryAction.js
var DeliveryAction = class extends Action {
  /**
   * @param {string} deliveryKey A generic Delivery Action Key (such as q, f, dn, etc.)
   * @param {string} deliveryType A Format Qualifiers for the action, such as Quality.auto()
   * @param {string} modelProperty internal model property of the action, for example quality uses `level` while dpr uses `density`
   * @see Visit {@link Actions.Delivery|Delivery} for an example
   */
  constructor(deliveryKey, deliveryType, modelProperty) {
    super();
    this._actionModel = {};
    let deliveryTypeValue;
    if (deliveryType instanceof FormatQualifier) {
      deliveryTypeValue = deliveryType.getValue();
    } else {
      deliveryTypeValue = deliveryType;
    }
    this._actionModel.actionType = DELIVERY_MODE_TO_ACTION_TYPE_MAP[deliveryKey];
    this._actionModel[modelProperty] = deliveryTypeValue;
    this.addQualifier(new Qualifier(deliveryKey, deliveryType));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/progressive.js
var ProgressiveQualifier = class extends FlagQualifier {
  constructor(mode2) {
    super("progressive", mode2);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryFormatAction.js
var DeliveryFormatAction = class extends DeliveryAction {
  constructor(deliveryKey, deliveryType) {
    super(deliveryKey, deliveryType, "formatType");
  }
  /**
   * @description Uses lossy compression when delivering animated GIF files.
   * @return {this}
   */
  lossy() {
    this._actionModel.lossy = true;
    this.addFlag(lossy());
    return this;
  }
  /**
   * @description Uses progressive compression when delivering JPG file format.
   * @return {this}
   */
  progressive(mode2) {
    if (mode2 instanceof ProgressiveQualifier) {
      this._actionModel.progressive = { mode: mode2.getFlagValue() };
      this.addFlag(mode2);
    } else {
      this._actionModel.progressive = { mode: mode2 };
      this.addFlag(progressive(mode2));
    }
    return this;
  }
  /**
   * @description Ensures that images with a transparency channel are delivered in PNG format.
   */
  preserveTransparency() {
    this._actionModel.preserveTransparency = true;
    this.addFlag(preserveTransparency());
    return this;
  }
  static fromJson(actionModel) {
    const { formatType, lossy: lossy2, progressive: progressive2, preserveTransparency: preserveTransparency2 } = actionModel;
    let result;
    if (formatType) {
      result = new this("f", formatType);
    } else {
      result = new this("f");
    }
    if (progressive2) {
      if (progressive2.mode) {
        result.progressive(progressive2.mode);
      } else {
        result.progressive();
      }
    }
    lossy2 && result.lossy();
    preserveTransparency2 && result.preserveTransparency();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/Transformation.js
var Transformation = class _Transformation {
  constructor() {
    this.actions = [];
  }
  /**
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    let actionToAdd;
    if (typeof action === "string") {
      if (action.indexOf("/") >= 0) {
        throw "addAction cannot accept a string with a forward slash in it - /, use .addTransformation() instead";
      } else {
        actionToAdd = new RawAction(action);
      }
    } else {
      actionToAdd = action;
    }
    this.actions.push(actionToAdd);
    return this;
  }
  /**
   * @description Allows the injection of a raw transformation as a string into the transformation, or a Transformation instance that was previously created
   * @param {string | SDK.Transformation} tx
   * @example
   * import {Transformation} from "@cloudinary/url-gen";
   *
   * const transformation = new Transformation();
   * transformation.addTransformation('w_100/w_200/w_300');
   * @return {this}
   */
  addTransformation(tx) {
    if (tx instanceof _Transformation) {
      this.actions = this.actions.concat(tx.actions);
    } else {
      this.actions.push(new RawAction(tx));
    }
    return this;
  }
  /**
   * @return {string}
   */
  toString() {
    return this.actions.map((action) => {
      return action.toString();
    }).filter((a) => a).join("/");
  }
  /**
   * @description Delivers an animated GIF.
   * @param {AnimatedAction} animatedAction
   * @return {this}
   */
  animated(animatedAction) {
    return this.addAction(animatedAction);
  }
  /**
   * @description Adds a border around the image.
   * @param {Border} borderAction
   * @return {this}
   */
  border(borderAction) {
    return this.addAction(borderAction);
  }
  /**
   * @description Adjusts the shape of the delivered image. </br>
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/effects_and_artistic_enhancements#distort|Shape changes and distortion effects}
   * @param {IReshape} reshapeAction
   * @return {this}
   */
  reshape(reshapeAction) {
    return this.addAction(reshapeAction);
  }
  /**
   * @description Resize the asset using provided resize action
   * @param {ResizeSimpleAction} resizeAction
   * @return {this}
   */
  resize(resizeAction) {
    return this.addAction(resizeAction);
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality2) {
    this.addAction(new DeliveryFormatAction("q", quality2));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format2) {
    this.addAction(new DeliveryFormatAction("f", format2));
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param roundCornersAction
   * @return {this}
   */
  roundCorners(roundCornersAction) {
    return this.addAction(roundCornersAction);
  }
  /**
   * @description Adds an overlay over the base image.
   * @param {LayerAction} overlayAction
   * @return {this}
   */
  overlay(overlayAction) {
    return this.addAction(overlayAction);
  }
  /**
   * @description Adds an underlay under the base image.
   * @param {LayerAction} underlayAction
   * @return {this}
   */
  underlay(underlayAction) {
    underlayAction.setLayerType("u");
    return this.addAction(underlayAction);
  }
  /**
   * @description Defines an new user variable.
   * @param {VariableAction} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    return this.addAction(variableAction);
  }
  /**
   * @description Specifies a condition to be met before applying a transformation.
   * @param {ConditionalAction} conditionAction
   * @return {this}
   */
  conditional(conditionAction) {
    return this.addAction(conditionAction);
  }
  /**
   * @description Applies a filter or an effect on an asset.
   * @param {SimpleEffectAction} effectAction
   * @return {this}
   */
  effect(effectAction) {
    return this.addAction(effectAction);
  }
  /**
   * @description Applies adjustment effect on an asset.
   * @param action
   * @return {this}
   */
  adjust(action) {
    return this.addAction(action);
  }
  /**
   * @description Rotates the asset by the given angle.
   * @param {RotateAction} rotateAction
   * @return {this}
   */
  rotate(rotateAction) {
    return this.addAction(rotateAction);
  }
  /**
   * @description Applies a pre-defined named transformation of the given name.
   * @param {NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    return this.addAction(namedTransformation);
  }
  /**
   * @description Applies delivery action.
   * @param deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    return this.addAction(deliveryAction);
  }
  /**
   * @description Sets the color of the background.
   * @param {Qualifiers.Color} color
   * @return {this}
   */
  backgroundColor(color2) {
    return this.addAction(new BackgroundColor(color2));
  }
  /**
   * @description Adds a layer in a Photoshop document.
   * @param action
   * @return {this}
   */
  psdTools(action) {
    return this.addAction(action);
  }
  /**
   * @description Extracts an image or a page using an index, a range, or a name from a layered media asset.
   * @param action
   * @return {this}
   */
  extract(action) {
    return this.addAction(action);
  }
  /**
   * @description Adds a flag as a separate action.
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    const action = new Action();
    let flagToAdd = flagQualifier;
    if (typeof flagQualifier === "string") {
      flagToAdd = new FlagQualifier(flagQualifier);
    }
    action.addQualifier(flagToAdd);
    return this.addAction(action);
  }
  /**
   * @description Inject a custom function into the image transformation pipeline.
   * @return {this}
   */
  customFunction(customFunction) {
    return this.addAction(customFunction);
  }
  /**
   * Transcodes the video (or audio) to another format.
   * @param {Action} action
   * @return {this}
   */
  transcode(action) {
    return this.addAction(action);
  }
  /**
   * Applies the specified video edit action.
   *
   * @param {videoEditType} action
   * @return {this}
   */
  videoEdit(action) {
    return this.addAction(action);
  }
  toJson() {
    const actions = [];
    for (const action of this.actions) {
      const json = action.toJson();
      if (isErrorObject(json)) {
        return json;
      }
      actions.push(json);
    }
    return { actions };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/ImageTransformation.js
var ImageTransformation = class extends Transformation {
};

// node_modules/@cloudinary/transformation-builder-sdk/transformation/VideoTransformation.js
var VideoTransformation = class extends Transformation {
};

// node_modules/@cloudinary/transformation-builder-sdk/backwards/consts.js
var NUMBER_PATTERN = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
var RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}$`);
var OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);

// node_modules/@cloudinary/transformation-builder-sdk/backwards/utils/snakeCase.js
var snakeCase = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/cloneDeep.js
var LARGE_ARRAY_SIZE = 200;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var promiseTag = "[object Promise]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!`${value}`;
    } catch (e) {
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? `Symbol(src)_1.${uid}` : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp(`^${funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
var Buffer = moduleExports ? root.Buffer : void 0;
var Symbol = root.Symbol;
var Uint8Array = root.Uint8Array;
var getPrototype = overArg(Object.getPrototypeOf, Object);
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var splice = arrayProto.splice;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, "DataView");
var Map = getNative(root, "Map");
var Promise2 = getNative(root, "Promise");
var Set = getNative(root, "Set");
var WeakMap = getNative(root, "WeakMap");
var nativeCreate = getNative(Object, "create");
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map);
var promiseCtorString = toSource(Promise2);
var setCtorString = toSource(Set);
var weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function Hash(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key).delete(key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}
function stackClear() {
  this.__data__ = new ListCache();
}
function stackDelete(key) {
  return this.__data__.delete(key);
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseGetTag(value) {
  return objectToString.call(value);
}
function baseIsNative(value) {
  if (!isObject3(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return `${func}`;
    } catch (e) {
    }
  }
  return "";
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction(value) {
  var tag = isObject3(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject3(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function stubArray() {
  return [];
}

// node_modules/@cloudinary/transformation-builder-sdk/backwards/configuration.js
var DEFAULT_CONFIGURATION_PARAMS = {
  responsive_class: "cld-responsive",
  responsive_use_breakpoints: true,
  round_dpr: true,
  secure: (typeof window !== "undefined" && window !== null ? window.location ? window.location.protocol : void 0 : void 0) === "https:"
};
var CONFIG_PARAMS = [
  "api_key",
  "api_secret",
  "callback",
  "cdn_subdomain",
  "cloud_name",
  "cname",
  "private_cdn",
  "protocol",
  "resource_type",
  "responsive",
  "responsive_class",
  "responsive_use_breakpoints",
  "responsive_width",
  "round_dpr",
  "secure",
  "secure_cdn_subdomain",
  "secure_distribution",
  "shorten",
  "type",
  "upload_preset",
  "url_suffix",
  "use_root_path",
  "version",
  "externalLibraries",
  "max_timeout_ms"
];

// node_modules/@cloudinary/transformation-builder-sdk/backwards/utils/legacyBaseUtil.js
var reWords = function() {
  var lower, upper;
  upper = "[A-Z]";
  lower = "[a-z]+";
  return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
}();

// node_modules/@cloudinary/transformation-builder-sdk/backwards/transformation.js
var number_pattern = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var offset_any_pattern = "(" + number_pattern + ")([%pP])?";
var methods = [
  "angle",
  "audioCodec",
  "audioFrequency",
  "aspectRatio",
  "background",
  "bitRate",
  "border",
  "color",
  "colorSpace",
  "crop",
  "customFunction",
  "customPreFunction",
  "defaultImage",
  "delay",
  "density",
  "duration",
  "dpr",
  "effect",
  "else",
  "endIf",
  "endOffset",
  "fallbackContent",
  "fetchFormat",
  "format",
  "flags",
  "gravity",
  "fps",
  "height",
  "htmlHeight",
  "htmlWidth",
  "if",
  "keyframeInterval",
  "ocr",
  "offset",
  "opacity",
  "overlay",
  "page",
  "poster",
  "prefix",
  "quality",
  "radius",
  "rawTransformation",
  "size",
  "sourceTypes",
  "sourceTransformation",
  "startOffset",
  "streamingProfile",
  "transformation",
  "underlay",
  "variable",
  "variables",
  "videoCodec",
  "videoSampling",
  "width",
  "x",
  "y",
  "zoom"
];
var PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/toFloatAsString.js
function toFloatAsString(value) {
  const returnValue = value.toString();
  if (returnValue.match(/[A-Z]/gi)) {
    return returnValue;
  }
  if (returnValue.length > 1 && returnValue[0] === "0") {
    return returnValue;
  }
  const isNumberLike3 = !isNaN(parseFloat(returnValue)) && returnValue.indexOf(":") === -1;
  if (isNumberLike3 && returnValue.indexOf(".") === -1) {
    return `${returnValue}.0`;
  } else {
    return returnValue;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeSimpleAction.js
var ResizeSimpleAction = class extends Action {
  /**
   * @param {string} cropType
   * @param {number | string} cropWidth The required width of a transformed asset.
   * @param {number | string} cropHeight The required height of a transformed asset.
   */
  constructor(cropType, cropWidth, cropHeight) {
    super();
    this._actionModel = { dimensions: {} };
    this._actionModel.actionType = CROP_MODE_TO_ACTION_TYPE_MAP[cropType] || cropType;
    this.addQualifier(new Qualifier("c", cropType));
    cropWidth && this.width(cropWidth);
    cropHeight && this.height(cropHeight);
  }
  /**
   * @description Sets the height of the resize
   * @param {string | number} x The height in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  height(x) {
    this._actionModel.dimensions.height = x;
    return this.addQualifier(new Qualifier("h", x));
  }
  /**
   * @description Sets the width of the resize
   * @param {string | number} x The width in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  width(x) {
    this._actionModel.dimensions.width = x;
    return this.addQualifier(new Qualifier("w", x));
  }
  /**
   * @description Sets the aspect ratio of the asset.
   * For a list of supported types see {@link Qualifiers.AspectRatio|
    * AspectRatio values}
   * @param {AspectRatioType|number|string} ratio The new aspect ratio, specified as a percentage or ratio.
   * @return {this}
   */
  aspectRatio(ratio) {
    if (ratio instanceof AspectRatioQualifierValue) {
      this._actionModel.dimensions.aspectRatio = `${ratio}`;
      return this.addQualifier(new Qualifier("ar", ratio));
    }
    if (typeof ratio === "number" || typeof ratio === "string") {
      this._actionModel.dimensions.aspectRatio = toFloatAsString(ratio);
      return this.addQualifier(new Qualifier("ar", toFloatAsString(ratio)));
    }
    if (ratio instanceof FlagQualifier) {
      this._actionModel.dimensions.aspectRatio = `${ratio.qualifierValue}`;
      return this.addFlag(ratio);
    }
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the containing image instead of the added layer.
   * @return {this}
   */
  relative() {
    this._actionModel.relative = true;
    return this.addFlag(relative());
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the overlaid region
   * @return {this}
   */
  regionRelative() {
    this._actionModel.regionRelative = true;
    return this.addFlag(regionRelative());
  }
  static fromJson(actionModel) {
    const { actionType, dimensions, relative: relative2, regionRelative: regionRelative2 } = actionModel;
    const { aspectRatio, width, height } = dimensions;
    const cropMode = ACTION_TYPE_TO_CROP_MODE_MAP[actionType] || actionType;
    const result = new this(cropMode, width, height);
    aspectRatio && result.aspectRatio(aspectRatio === "ignore_aspect_ratio" ? ignoreInitialAspectRatio() : aspectRatio);
    relative2 && result.relative();
    regionRelative2 && result.regionRelative();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeAdvancedAction.js
var ResizeAdvancedAction = class extends ResizeSimpleAction {
  /**
   * @description Which part of the original image to include.
   * @param {Qualifiers.Gravity} gravity
   */
  gravity(gravity) {
    this._actionModel.gravity = createGravityModel(gravity);
    const gravityQualifier = typeof gravity === "string" ? new Qualifier("g", gravity) : gravity;
    return this.addQualifier(gravityQualifier);
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    if (actionModel.gravity) {
      result.gravity(createGravityFromModel(actionModel.gravity));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundModel.js
function getBackgroundValue(background) {
  return `${background}`.replace("b_", "");
}
function createAutoBackgroundModel() {
  return { backgroundType: "auto" };
}
function createBlurredBackgroundModel(background) {
  const { intensityLevel, brightnessLevel } = background;
  const result = {
    backgroundType: "blurred"
  };
  if (intensityLevel || intensityLevel === 0) {
    result.intensity = intensityLevel;
  }
  if (brightnessLevel || brightnessLevel === 0) {
    result.brightness = brightnessLevel;
  }
  return result;
}
function createContrastPaletteBackgroundModel(background) {
  const contrast2 = background._contrast;
  const palette = background._palette;
  const result = {
    backgroundType: ""
  };
  if (contrast2) {
    result.contrast = true;
  }
  if (palette) {
    result.palette = palette;
  }
  return result;
}
function createBorderBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "border" });
}
function createBaseGradientBackgroundModel(background) {
  const gradientColors = background._gradientColors;
  const gradientDirection = `${background._gradientDirection}`;
  const result = createContrastPaletteBackgroundModel(background);
  if (gradientColors) {
    result.gradientColors = gradientColors;
  }
  if (gradientDirection) {
    result.gradientDirection = gradientDirection;
  }
  return result;
}
function createBorderGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "borderGradient" });
}
function createColorBackgroundModel(background) {
  return {
    backgroundType: "color",
    color: getBackgroundValue(background)
  };
}
function createPredominantBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "predominant" });
}
function createPredominantGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "predominantGradient" });
}
function createGenerativeFillBackgroundModel(background) {
  return Object.assign({ backgroundType: background.getBackgroundType() }, background.getPrompt() ? { prompt: background.getPrompt() } : {});
}
function createBackgroundModel(background) {
  if (getBackgroundValue(background) === "auto") {
    return createAutoBackgroundModel();
  }
  if (background instanceof BlurredBackgroundAction_default) {
    return createBlurredBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoBorderQualifier) {
    return createBorderBackgroundModel(background);
  }
  if (background instanceof BackgroundBorderGradientQualifier) {
    return createBorderGradientBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoPredominantQualifier) {
    return createPredominantBackgroundModel(background);
  }
  if (background instanceof BackgroundPredominantGradientQualifier) {
    return createPredominantGradientBackgroundModel(background);
  }
  if (background instanceof BackgroundGenerativeFillQualifier) {
    return createGenerativeFillBackgroundModel(background);
  }
  return createColorBackgroundModel(background);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundFromModel.js
function createBlurredBackground(backgroundModel) {
  const { brightness: brightness2, intensity } = backgroundModel;
  const result = Background.blurred();
  result.brightness(brightness2 !== null && brightness2 !== void 0 ? brightness2 : DEFAULT_BRIGHTNESS);
  result.intensity(intensity !== null && intensity !== void 0 ? intensity : DEFAULT_INTENSITY);
  return result;
}
function createGradientBackground(background, backgroundModel) {
  const { gradientColors, gradientDirection, contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  if (gradientColors) {
    background.gradientColors(+gradientColors);
  }
  if (gradientDirection) {
    background.gradientDirection(gradientDirection);
  }
  return background;
}
function createContrastPaletteBackground(background, backgroundModel) {
  const { contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  return background;
}
function createGenerativeFillBackground(background, backgroundModel) {
  const { prompt } = backgroundModel;
  if (prompt) {
    background.prompt(prompt);
  }
  return background;
}
function createBackgroundFromModel(backgroundModel) {
  const { backgroundType } = backgroundModel;
  switch (backgroundType) {
    case "auto":
      return auto();
    case "blurred":
      return createBlurredBackground(backgroundModel);
    case "border":
      return createContrastPaletteBackground(border(), backgroundModel);
    case "borderGradient":
      return createGradientBackground(borderGradient(), backgroundModel);
    case "predominant":
      return createContrastPaletteBackground(predominant(), backgroundModel);
    case "predominantGradient":
      return createGradientBackground(predominantGradient(), backgroundModel);
    case "generativeFill":
      return createGenerativeFillBackground(generativeFill(), backgroundModel);
    default:
      return color(backgroundModel.color);
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizePadAction.js
var ResizePadAction = class extends ResizeAdvancedAction {
  /**
   * @description Sets the background.
   * @param {Qualifiers.Background} backgroundQualifier Defines the background color to use instead of
   * transparent background areas or when resizing with padding.
   */
  background(backgroundQualifier) {
    this._actionModel.background = createBackgroundModel(backgroundQualifier);
    return this.addQualifier(backgroundQualifier);
  }
  /**
   * @description Horizontal position for custom-coordinates based padding.
   * @param {number} x The x position.
   */
  offsetX(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based padding
   * @param {number} y The y position.
   */
  offsetY(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.background && result.background(createBackgroundFromModel(actionModel.background));
    actionModel.x && result.offsetX(actionModel.x);
    actionModel.y && result.offsetY(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeScaleAction.js
var ResizeScaleAction = class extends ResizeSimpleAction {
  /**
   * @description Changes the aspect ratio of an image while retaining all important content and avoiding unnatural
   * distortions.
   * @return {this}
   */
  liquidRescaling() {
    return this.addQualifier(new GravityQualifier("liquid"));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ThumbnailAction.js
var ThumbResizeAction = class extends ResizeAdvancedAction {
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeCropAction.js
var ResizeCropAction = class extends ResizeAdvancedAction {
  /**
   * @description Horizontal position for custom-coordinates based cropping.
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based cropping
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeFillAction.js
var ResizeFillAction = class extends ResizeAdvancedAction {
  /**
   * @description Absolute X position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Absolute Y position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFitAction.js
var ResizeLimitFitAction = class extends ResizeSimpleAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFillAction.js
var ResizeLimitFillAction = class extends ResizeFillAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitPadAction.js
var ResizeLimitPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeMinimumPadAction.js
var ResizeMinimumPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeAutoPadAction.js
var ResizeAutoPadAction = class extends ResizeSimpleAction {
  constructor(cropType, cropWidth, cropHeight) {
    super(cropType, cropWidth, cropHeight);
    this.addQualifier(new Qualifier("g", "auto"));
  }
  /**
   * @description Sets the background.
   * @param {Qualifiers.Background} backgroundQualifier Defines the background color to use instead of
   * transparent background areas or when resizing with padding.
   */
  background(backgroundQualifier) {
    this._actionModel.background = createBackgroundModel(backgroundQualifier);
    return this.addQualifier(backgroundQualifier);
  }
  gravity(gravity) {
    return this;
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.background && result.background(createBackgroundFromModel(actionModel.background));
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize.js
function scale(width, height) {
  return new ResizeScaleAction("scale", width, height);
}
function imaggaScale(width, height) {
  return new ResizeSimpleAction("imagga_scale", width, height);
}
function imaggaCrop(width, height) {
  return new ResizeSimpleAction("imagga_crop", width, height);
}
function crop(width, height) {
  return new ResizeCropAction("crop", width, height);
}
function fill(width, height) {
  return new ResizeFillAction("fill", width, height);
}
function fit(width, height) {
  return new ResizeSimpleAction("fit", width, height);
}
function pad(width, height) {
  return new ResizePadAction("pad", width, height);
}
function limitFill(width, height) {
  return new ResizeLimitFillAction("lfill", width, height);
}
function limitFit(width, height) {
  return new ResizeLimitFitAction("limit", width, height);
}
function minimumPad(width, height) {
  return new ResizeMinimumPadAction("mpad", width, height);
}
function minimumFit(width, height) {
  return new ResizeSimpleAction("mfit", width, height);
}
function fillPad(width, height) {
  return new ResizePadAction("fill_pad", width, height);
}
function thumbnail(width, height) {
  return new ThumbResizeAction("thumb", width, height);
}
function auto2(width, height) {
  return new ResizeAdvancedAction("auto", width, height);
}
function limitPad(width, height) {
  return new ResizeLimitPadAction("lpad", width, height);
}
function autoPad(width, height) {
  return new ResizeAutoPadAction("auto_pad", width, height);
}
var Resize = {
  imaggaScale,
  imaggaCrop,
  crop,
  fill,
  scale,
  minimumPad,
  fit,
  pad,
  limitFit,
  thumbnail,
  limitFill,
  minimumFit,
  limitPad,
  fillPad,
  auto: auto2,
  autoPad
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners/RoundCornersAction.js
var RoundCornersAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "roundCorners";
  }
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @return {RoundCornersAction}
   */
  radius(a, b, c, d) {
    const qualifierValue = new QualifierValue();
    a !== void 0 && qualifierValue.addValue(a);
    b !== void 0 && qualifierValue.addValue(b);
    c !== void 0 && qualifierValue.addValue(c);
    d !== void 0 && qualifierValue.addValue(d);
    const definedRadiuses = [a, b, c, d].filter((r) => r !== void 0);
    this._radius = definedRadiuses;
    this._actionModel.radius = definedRadiuses;
    this.addQualifier(new Qualifier("r").addValue(qualifierValue));
    return this;
  }
  /**
   * @description Applies maximum rounding to the corners of the asset. An asset with square dimensions becomes a circle.
   */
  max() {
    this._radius = "max";
    this._actionModel.radius = "max";
    return this.addQualifier(new Qualifier("r", "max"));
  }
  getRadius() {
    return this._radius;
  }
  static fromJson(actionModel) {
    const { radius } = actionModel;
    const result = new this();
    if (Array.isArray(radius)) {
      result.radius(radius[0], radius[1], radius[2], radius[3]);
    }
    if (radius === "max") {
      result.max();
    }
    return result;
  }
};
var RoundCornersAction_default = RoundCornersAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/border.js
var BorderAction = class extends Action {
  /**
   * @description Adds a border of the specified type around an image or video.
   * @param {'solid'} borderType The type of border (currently only 'solid' is supported). Use values in {@link Qualifiers.Border|Border Values}.
   * @param {string} color The color of the border.
   * @param {number} borderWidth The width in pixels.
   */
  constructor(borderType, color2, borderWidth) {
    super();
    this._actionModel = {};
    this.borderType = borderType;
    this.borderColor = prepareColor(color2);
    this.borderWidth = borderWidth;
    this._actionModel = {
      color: prepareColor(color2),
      width: borderWidth,
      actionType: "border"
    };
  }
  /**
   * @description Sets the width of the border
   * @param {number | string} borderWidth The width in pixels.
   */
  width(borderWidth) {
    this.borderWidth = borderWidth;
    this._actionModel.width = borderWidth;
    return this;
  }
  /**
   * @description Sets the color of the border.
   * @param {string} borderColor The color of the border.
   */
  color(borderColor) {
    this.borderColor = prepareColor(borderColor);
    this._actionModel.color = prepareColor(borderColor);
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param {RoundCornersAction} roundCorners
   * @return {this}
   */
  roundCorners(roundCorners2) {
    this._roundCorners = roundCorners2;
    this._actionModel.radius = roundCorners2.getRadius();
    return this;
  }
  /**
   * @description Sets the style of the border.
   * @param {number | string} width The width in pixels.
   * @param {string} color The color of the border, e.g 'green', 'yellow'.
   * @return {this}
   */
  solid(width, color2) {
    this.borderType = "solid";
    this.borderColor = prepareColor(color2);
    this.borderWidth = width;
    this._actionModel.color = prepareColor(color2);
    this._actionModel.width = width;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue([`${this.borderWidth}px`, this.borderType, `${this.borderColor}`]).setDelimiter("_");
    this.addQualifier(new Qualifier("bo", qualifierValue));
    if (this._roundCorners) {
      this.addQualifier(this._roundCorners.qualifiers.get("r"));
    }
  }
  static fromJson(actionModel) {
    const { width, color: color2, radius } = actionModel;
    const result = new this("solid", color2, width);
    if (radius) {
      const roundCornersAction = (() => {
        if (radius === "max") {
          return new RoundCornersAction_default().max();
        }
        if (Array.isArray(radius)) {
          return new RoundCornersAction_default().radius(...radius);
        }
        return void 0;
      })();
      if (roundCornersAction) {
        result.roundCorners(roundCornersAction);
      }
    }
    return result;
  }
};
function solid(width, color2) {
  return new BorderAction("solid", color2, width);
}
function roundCorners(roundCorners2) {
  const borderActionInstance = new BorderAction("solid", "transparent", 0);
  borderActionInstance.roundCorners(roundCorners2);
  return borderActionInstance;
}
var Border = {
  solid,
  roundCorners
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners.js
function max() {
  return new RoundCornersAction_default().max();
}
function byRadius(a, b, c, d) {
  return new RoundCornersAction_default().radius(a, b, c, d);
}
var RoundCorners = { byRadius, max };

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Blur.js
var BlurAction = class extends Action {
  constructor(strength) {
    super();
    this._actionModel = {};
    this._strength = strength;
    this._actionModel.actionType = "blur";
    this._actionModel.strength = strength;
  }
  /**
   * @description Specifies the region to blur.
   * @param {NamedRegion} blurRegion
   */
  region(blurRegion) {
    this._region = blurRegion;
    this._actionModel.region = blurRegion.toJson();
    return this;
  }
  /**
   * @description Sets the strength of the blur effect.
   * @param {number | string} strength
   */
  strength(strength) {
    this._strength = strength;
    this._actionModel.strength = strength;
    return this;
  }
  prepareQualifiers() {
    const strength = this._strength ? `:${this._strength}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "custom") {
        this.addQualifier(new Qualifier("e", `blur_region${strength}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `blur_region${strength}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `blur_faces${strength}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `blur${strength}`));
    }
  }
  static fromJson(actionModel) {
    const { strength, region } = actionModel;
    const result = new this(strength);
    strength && result.strength(strength);
    if (region && region.regionType === "faces") {
      result.region(faces());
    }
    if (region && region.regionType === "ocr_text") {
      result.region(ocr());
    }
    if (region && region.regionType === "custom") {
      result.region(CustomRegion.fromJson(region));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Accelerate.js
var AccelerationEffectAction = class extends Action {
  constructor(rate) {
    super();
    this._actionModel = { actionType: "accelerate" };
    rate && this.rate(rate);
  }
  rate(rate) {
    this._actionModel.rate = rate;
    this._rate = rate;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["accelerate", this._rate]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { rate } = actionModel;
    const result = new this();
    rate && result.rate(rate);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/SimpleEffectAction.js
var SimpleEffectAction = class extends Action {
  constructor(effectType, level) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    const qualifierEffect = this.createEffectQualifier(effectType, level);
    this.addQualifier(qualifierEffect);
  }
  createEffectQualifier(effectType, level) {
    let qualifierValue;
    if (level) {
      qualifierValue = new QualifierValue([effectType, `${level}`]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(effectType);
    }
    return new Qualifier("e", qualifierValue);
  }
  static fromJson(actionModel) {
    const { actionType, level, strength } = actionModel;
    const effectType = ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType] || actionType;
    const result = new this(effectType, level ? level : strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/LeveledEffectAction.js
var LeveledEffectAction = class extends SimpleEffectAction {
  constructor(effectType, level) {
    super(effectType, level);
    this.LEVEL_NAME = "level";
    this._actionModel = {};
    this.effectType = effectType;
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    if (level) {
      this.setLevel(level);
    }
  }
  /**
   *
   * @description Sets the effect level for the action
   * @param {string | number} level - The strength of the effect
   * @protected
   */
  setLevel(level) {
    this._actionModel[this.LEVEL_NAME] = level;
    const qualifierEffect = this.createEffectQualifier(this.effectType, level);
    this.addQualifier(qualifierEffect);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Loop.js
var LoopEffectAction = class extends LeveledEffectAction {
  additionalIterations(value) {
    this._actionModel.iterations = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, iterations } = actionModel;
    const result = new this(actionType, iterations);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Cartoonify.js
var CartoonifyEffect = class extends Action {
  constructor(effectName, strength) {
    super();
    this._actionModel = {};
    this.cartoonifyStrength = strength;
    this.effectName = effectName;
    this._actionModel.actionType = effectName;
  }
  /**
   * @description Sets the thickness of the lines.
   * @param {number} lineStrength The thickness of the lines. (Range: 0 to 100, Server default: 50)
   * @return {this}
   */
  lineStrength(lineStrength) {
    this.cartoonifyStrength = lineStrength;
    this._actionModel.lineStrength = lineStrength;
    return this;
  }
  /**
   * @description Achieves a black and white cartoon effect.
   * @return {this}
   */
  blackwhite() {
    this._actionModel.blackAndWhite = true;
    this.colorReduction = "bw";
    return this;
  }
  /**
   * @description
   * Sets the decrease in the number of colors and corresponding saturation boost of the remaining colors. <br/>
   * Higher reduction values result in a less realistic look.
   * @param {number } level The decrease in the number of colors and corresponding saturation boost of the remaining colors. (Range: 0 to 100, Server default: automatically adjusts according to the line_strength value). Set to 'bw' for a black and white cartoon effect.
   * @return {this}
   */
  colorReductionLevel(level) {
    this._actionModel.colorReductionLevel = level;
    this.colorReduction = level;
    return this;
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue([this.effectName, this.cartoonifyStrength, this.colorReduction])));
    return;
  }
  static fromJson(actionModel) {
    const { actionType, lineStrength, blackAndWhite, colorReductionLevel } = actionModel;
    const result = new this(actionType, lineStrength);
    blackAndWhite && result.blackwhite();
    colorReductionLevel && result.colorReductionLevel(colorReductionLevel);
    lineStrength && result.lineStrength(lineStrength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Outline.js
var EffectOutline = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "outline";
  }
  /**
   * @description
   * How to apply the outline effect which can be one of the following values:
   * inner, inner_fill, outer, fill.
   * @param {OutlineModeType|string} mode  The type of outline effect. Use the constants defined in Outline.
   * @return {this}
   */
  mode(mode2) {
    this._actionModel.mode = mode2;
    this._mode = mode2;
    return this;
  }
  /**
   * The thickness of the outline in pixels. (Range: 1 to 100, Server default: 5)
   * @param {number} width
   * @return {this}
   */
  width(width) {
    this._actionModel.width = width;
    this._width = width;
    return this;
  }
  /**
   * @description
   * The level of blur of the outline.
   * Range: 0 to 2000, Server default: 0
   * @param {number | string} lvl
   * @return {this}
   */
  blurLevel(lvl) {
    this._actionModel.blurLevel = lvl;
    this._blurLevel = lvl;
    return this;
  }
  /**
   * @param {string | Qualifiers.Color} color One of the SDK Color values, string, or rgba: '#fff'
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", prepareColor(color2)));
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue(["outline", this._mode, this._width, this._blurLevel]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, mode: mode2, color: color2, blurLevel, width } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    color2 && result.color(color2);
    blurLevel && result.blurLevel(blurLevel);
    width && result.width(width);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/MakeTransparent.js
var MakeTransparentEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "makeTransparent" };
  }
  /**
   * @description Sets the tolerance used to accommodate variance in the background color.
   * @param {number | string} value The tolerance used to accommodate variance in the background color. (Range: 0 to 100, Server default: 10)
   */
  tolerance(value) {
    this._actionModel.tolerance = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  /**
   * @description Sets the color to make transparent.
   * @param {string} color The HTML name of the color (red, green, etc.) or RGB hex code.
   * @return {this}
   */
  colorToReplace(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, tolerance, color: color2 } = actionModel;
    const result = new this(ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType], tolerance);
    tolerance && result.tolerance(tolerance);
    color2 && result.colorToReplace(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Vectorize.js
var VectorizeEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "vectorize";
  }
  /**
   * @description The number of colors. (Range: 2 to 30, Server default: 10)
   * @param {number | string} num
   * @return {this}
   */
  numOfColors(num2) {
    this._actionModel.numOfColors = num2;
    this._numOfColors = num2;
    return this;
  }
  /**
   * @description The level of detail. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 1000). (Server default: 300)
   * @param {number | string} num
   * @return {this}
   */
  detailsLevel(num2) {
    this._actionModel.detailLevel = num2;
    this._detailsLevel = num2;
    return this;
  }
  /**
   * @description The size of speckles to suppress. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 100, Server default: 2)
   * @param {number | string} num
   * @return {this}
   */
  despeckleLevel(num2) {
    this._actionModel.despeckleLevel = num2;
    this._despeckleLevel = num2;
    return this;
  }
  /**
   * @description The corner threshold. Specify 100 for no smoothing (polygon corners), 0 for completely smooth corners. (Range: 0 to 100, Default: 25)
   * @param {number | string} num
   * @return {this}
   */
  cornersLevel(num2) {
    this._actionModel.cornersLevel = num2;
    this._cornersLevel = num2;
    return this;
  }
  /**
   * @description The optimization value. Specify 100 for least optimization and the largest file. (Range: 0 to 100, Server default: 100).
   * @param {number} num
   * @return {this}
   */
  paths(num2) {
    this._actionModel.paths = num2;
    this._paths = num2;
    return this;
  }
  prepareQualifiers() {
    let str = "vectorize";
    if (this._numOfColors) {
      str += `:${new QualifierValue(`colors:${this._numOfColors}`).toString()}`;
    }
    if (this._detailsLevel) {
      str += `:${new QualifierValue(`detail:${this._detailsLevel}`).toString()}`;
    }
    if (this._despeckleLevel) {
      str += `:${new QualifierValue(`despeckle:${this._despeckleLevel}`).toString()}`;
    }
    if (this._paths) {
      str += `:${new QualifierValue(`paths:${this._paths}`).toString()}`;
    }
    if (this._cornersLevel) {
      str += `:${new QualifierValue(`corners:${this._cornersLevel}`).toString()}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, paths, cornersLevel, despeckleLevel, detailLevel, numOfColors } = actionModel;
    const result = new this();
    paths && result.paths(paths);
    cornersLevel && result.cornersLevel(cornersLevel);
    despeckleLevel && result.despeckleLevel(despeckleLevel);
    detailLevel && result.detailsLevel(detailLevel);
    numOfColors && result.numOfColors(numOfColors);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/SimulateColorBlind.js
var SimulateColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "simulateColorblind";
    this.addQualifier(new Qualifier("e", `simulate_colorblind`));
  }
  setQualifier(val) {
    const strToAppend = `:${val}`;
    if (val) {
      this.addQualifier(new Qualifier("e", `simulate_colorblind${strToAppend}`));
    }
    return this;
  }
  /**
   * @description Sets the color blind condition to simulate.
   * @param {Qualifiers.simulateColorBlindValues | SimulateColorBlindType | string} cond
   * @return {this}
   */
  condition(cond) {
    this._actionModel.condition = cond;
    return this.setQualifier(cond);
  }
  static fromJson(actionModel) {
    const { actionType, condition } = actionModel;
    const result = new this();
    condition && result.condition(condition);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithLevel.js
var EffectActionWithLevel = class extends LeveledEffectAction {
  level(value) {
    this._actionModel.level = value;
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/AssistColorBlind.js
var AssistColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "assistColorblind";
    this.addQualifier(new Qualifier("e", new QualifierValue("assist_colorblind")));
  }
  /**
   * @description Replaces problematic colors with colors that are easier to differentiate.
   * @return {this}
   */
  xray() {
    this._actionModel.type = "xray";
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", "xray"]).setDelimiter(":")));
  }
  /**
   * @description Applies stripes of the specified intensity to help people with common color blind conditions to differentiate between colors that are similar for them.
   * @param {number | string} strength The intensity of the stripes. (Range: 1 to 100, Server default: 10)
   * @return {this}
   */
  stripesStrength(strength) {
    this._actionModel.type = "stripes";
    this._actionModel.stripesStrength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", strength]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, type, stripesStrength } = actionModel;
    const result = new this();
    if (type === "xray") {
      result.xray();
    }
    if (type === "stripes") {
      stripesStrength && result.stripesStrength(stripesStrength);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GradientFade.js
var GradientFadeEffectAction = class extends Action {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "gradientFade" };
  }
  /**
   * @description Sets the strength of the fade effect.
   * @param {number} strength The strength of the fade effect. (Range: 0 to 100, Server default: 20)
   */
  strength(strength) {
    this._actionModel.strength = strength;
    this._strength = strength;
    return this;
  }
  /**
   * @description Sets the mode of gradient fade.
   * @param {string | Qualifiers.GradientFade} type The mode of gradient fade.
   */
  type(type) {
    this._actionModel.type = type;
    this._type = type;
    return this;
  }
  /**
   * @description Sets the x dimension of the start point.
   * @param {number | string} x The x dimension of the start point.
   */
  horizontalStartPoint(x) {
    this._actionModel.horizontalStartPoint = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Sets the y dimension of the start point.
   * @param {number | string} y The y dimension of the start point.
   */
  verticalStartPoint(y) {
    this._actionModel.verticalStartPoint = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  prepareQualifiers() {
    let str = "gradient_fade";
    if (this._type) {
      str += `:${this._type}`;
    }
    if (this._strength) {
      str += `:${this._strength}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, verticalStartPoint, horizontalStartPoint, type, strength } = actionModel;
    const result = new this();
    verticalStartPoint && result.verticalStartPoint(verticalStartPoint);
    horizontalStartPoint && result.horizontalStartPoint(horizontalStartPoint);
    type && result.type(type);
    strength && result.strength(strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeOut.js
var FadeOutEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeOut" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Colorize.js
var ColorizeEffectAction = class extends EffectActionWithLevel {
  /**
   * @description The color to use for colorization. Specify HTML name or RGB hex code. (Server default: gray)
   * @param {string} color HTML name(red, green, etc.) or RGB hex code. (Server default: gray)
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, level, color: color2 } = actionModel;
    const result = new this(actionType, level);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Shadow.js
var ShadowEffectAction = class extends Action {
  constructor(effectType, strength) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = effectType;
    this.effectType = effectType;
    this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} strength
   * @return {this}
   */
  strength(strength) {
    this._actionModel.strength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The X offset the shadow
   * @param {number | SDK.ExpressionQualifier} x
   * @return {this}
   */
  offsetX(x) {
    this._actionModel.offsetX = x;
    return this.addQualifier(new Qualifier("x", new QualifierValue(x)));
  }
  /**
   * @description The Y offset the shadow
   * @param {number | SDK.ExpressionQualifier} y
   * @return {this}
   */
  offsetY(y) {
    this._actionModel.offsetY = y;
    return this.addQualifier(new Qualifier("y", new QualifierValue(y)));
  }
  /**
   * @description The color of the shadow (Server default: gray)
   * @param color
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, strength, offsetX, offsetY, color: color2 } = actionModel;
    const result = new this(actionType, strength);
    offsetX && result.offsetX(offsetX);
    offsetY && result.offsetY(offsetY);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/StyleTransfer.js
var StyleTransfer = class extends Action {
  /**
   * The Image Source used to create the style transfer,
   * Use the Image Source builder to quickly create a source:
   * </br>Import: {@link Qualifiers.Source|import Sources from '@cloudinary/url-gen/qualifiers/sources';}
   * </br>Create: `Source.image('dog')`
   * @param {ImageSource} imageSource
   */
  constructor(imageSource) {
    super();
    this.imageSource = imageSource;
  }
  /**
   * Determines the strength in which the styleTransfer is applied.
   * @param {number} [effectStrength] - The strength level, 1-100, default: 100
   * @return {this}
   */
  strength(effectStrength = null) {
    this.effectStrength = effectStrength;
    return this;
  }
  /**
   * More aggressively preserves the colors of the the target photo,
   * Can be used with `strength()` to enhance this behaviour
   * @param {boolean} bool
   * @return {this}
   */
  preserveColor(bool = true) {
    this.preserve = bool;
    return this;
  }
  /**
   * The `build` phase of the Action, used internally to concat all the options received into a single string.
   * The result of this method is the toString() of the imageLayer provided in the constructor.
   * @return {string}
   */
  toString() {
    const NAME = "style_transfer";
    const PRES = this.preserve ? "preserve_color" : null;
    const STRENGTH = this.effectStrength;
    const styleEffect = new Qualifier("e", new QualifierValue([NAME, PRES, STRENGTH]));
    const sourceOpenString = this.imageSource.getOpenSourceString("l");
    const imgTx = this.imageSource.getTransformation();
    const sourceTransformation = imgTx ? imgTx.toString() : "";
    return [
      sourceOpenString,
      sourceTransformation,
      `${styleEffect},fl_layer_apply`
    ].filter((a) => a).join("/");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Dither.js
var DitherEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "dither" };
  }
  /**
   *
   * @param {Qualifiers.Dither} ditherType - The dither type applied to the image
   * @return {this}
   */
  type(ditherType) {
    this._actionModel.type = ditherType;
    const qualifierEffect = this.createEffectQualifier(this.effectType, ditherType);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, type } = actionModel;
    const result = new this(actionType);
    type && result.type(type);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Deshake.js
var DeshakeEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "deshake" };
  }
  /**
   * The maximum number of pixels in the horizontal and vertical direction that will be addressed. (Possible values: 16, 32, 48, 64. Server default: 16)
   * @param value Possible values: 16, 32, 48, 64.  Server default: 16.
   */
  shakeStrength(value) {
    this._actionModel.pixels = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, pixels } = actionModel;
    const result = new this(actionType, pixels);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/pixelate/Pixelate.js
var Pixelate = class extends Action {
  constructor(squareSize) {
    super();
    this._actionModel = {};
    this._squareSize = squareSize;
    this._actionModel.actionType = "pixelate";
    this._actionModel.squareSize = squareSize;
  }
  /**
   * @description Specifies the region to piexlate.
   * @param {NamedRegion} pixelateRegion
   */
  region(pixelateRegion) {
    this._region = pixelateRegion;
    this._actionModel.region = { regionType: this._region.regionType };
    return this;
  }
  /**
   * @description Sets the squareSize of the pixelate effect.
   * @param {number | string} squareSize
   */
  squareSize(squareSize) {
    this._squareSize = squareSize;
    this._actionModel.squareSize = squareSize;
    return this;
  }
  prepareQualifiers() {
    const str = this._squareSize ? `:${this._squareSize}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "custom") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `pixelate_faces${str}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `pixelate${str}`));
    }
  }
  static fromJson(actionModel) {
    const { region, squareSize } = actionModel;
    const result = new this(squareSize);
    squareSize && result.squareSize(squareSize);
    if (region && region.regionType === "faces") {
      result.region(faces());
    }
    if (region && region.regionType === "custom") {
      result.region(custom());
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithStrength.js
var EffectActionWithStrength = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this.LEVEL_NAME = "strength";
  }
  strength(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Blackwhite.js
var BlackwhiteEffectAction = class extends LeveledEffectAction {
  threshold(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeIn.js
var FadeInEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeIn" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/RemoveBackgroundAction.js
var RemoveBackgroundAction = class extends Action {
  constructor() {
    super();
    this.overwriteQualifier();
  }
  /**
   * @description Everytime this method is called, it will overwrite the e_bgremoval qualifier with new values
   * @private
   */
  overwriteQualifier() {
    const value = ["bgremoval", this._screen ? "screen" : "", (this._colorToRemove || "").replace("#", "")];
    return this.addQualifier(new Qualifier("e", new QualifierValue(value)));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} useScreen Boolean, defaults to true
   * @return {this}
   */
  screen(useScreen = true) {
    this._screen = useScreen;
    return this.overwriteQualifier();
  }
  /**
   * @description The color to remove from the background
   * @param {SystemColors} color
   * @return {this}
   */
  colorToRemove(color2) {
    this._colorToRemove = color2;
    return this.overwriteQualifier();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Theme.js
var ThemeEffect = class extends Action {
  constructor(color2) {
    super();
    this.effectName = "theme";
    this.color = color2;
  }
  /**
   * @description The sensitivity to photographic elements of an image.
   *              A value of 0 treats the whole image as non-photographic.
   *              A value of 200 treats the whole image as photographic, so no theme change is applied.
   * @param {number} photosensitivity
   * @return {this}
   */
  photosensitivity(photosensitivity) {
    this._photosensitivity = photosensitivity;
    return this;
  }
  prepareQualifiers() {
    const sensitivity = this._photosensitivity ? `:photosensitivity_${this._photosensitivity}` : "";
    const val = `${this.effectName}:color_${this.color.replace("#", "")}${sensitivity}`;
    this.addQualifier(new Qualifier("e", new QualifierValue(val)));
    return;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/BackgroundRemoval.js
var BackgroundRemoval = class extends Action {
  constructor() {
    super();
    this._actionModel.actionType = "backgroundRemoval";
  }
  fineEdges(value = true) {
    this._fineEdges = value;
    this._actionModel.fineEdges = this._fineEdges;
    return this;
  }
  hints(...values) {
    if (values.length === 1 && Array.isArray(values[0])) {
      this._hints = values[0];
    } else if (values.length) {
      this._hints = values;
    }
    if (this._hints) {
      this._actionModel.hints = this._hints;
    }
    return this;
  }
  prepareQualifiers() {
    var _a;
    let str = "background_removal";
    const params = [];
    if (this._fineEdges !== void 0) {
      params.push(new QualifierValue(`fineedges_${this._fineEdges ? "y" : "n"}`).toString());
    }
    if ((_a = this._hints) === null || _a === void 0 ? void 0 : _a.length) {
      params.push(new QualifierValue(`hints_(${this._hints.join(";")})`).toString());
    }
    if (params.length > 0) {
      str += `:${params.join(";")}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { fineEdges, hints } = actionModel;
    const result = new this();
    if (fineEdges !== void 0) {
      result.fineEdges(fineEdges);
    }
    if (hints === null || hints === void 0 ? void 0 : hints.length) {
      result.hints(hints);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/DropShadow.js
var DropShadow = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "dropshadow";
  }
  /**
   * @description
   * The direction the light is coming from to cause the shadow effect. (Range: 0 to 360, Server default: 215)
   * @param {number} azimuth
   * @return {this}
   */
  azimuth(azimuth) {
    this._actionModel.azimuth = azimuth;
    this._azimuth = azimuth;
    return this;
  }
  /**
   * @description
   * The height of the light source above the 'ground' to cause the shadow effect. (Range: 0 to 90, Server default: 45)
   * @param {number} elevation
   * @return {this}
   */
  elevation(elevation) {
    this._actionModel.elevation = elevation;
    this._elevation = elevation;
    return this;
  }
  /**
   * @description
   * The spread of the light source. A small number means 'point' light. A larger number means 'area' light. (Range: 0 to 100, Server default: 50)
   * @param {number} spread
   * @return {this}
   */
  spread(spread) {
    this._actionModel.spread = spread;
    this._spread = spread;
    return this;
  }
  prepareQualifiers() {
    const paramNames = ["azimuth", "elevation", "spread"];
    const paramValues = [this._azimuth, this._elevation, this._spread];
    const paramString = paramValues.map((value, index) => value !== void 0 ? `${paramNames[index]}_${value}` : "").filter(Boolean).join(";");
    this.addQualifier(new Qualifier("e", new QualifierValue(["dropshadow", paramString]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { azimuth, elevation, spread } = actionModel;
    const result = new this();
    azimuth && result.azimuth(azimuth);
    elevation && result.elevation(elevation);
    spread && result.spread(spread);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeRemove.js
var GenerativeRemove = class extends Action {
  constructor() {
    super();
    this._prompts = [];
    this._regions = [];
    this._detectMultiple = false;
    this._removeShadow = false;
    this._actionModel.actionType = "generativeRemove";
  }
  prompt(...value) {
    this._prompts = value;
    if (this._prompts.length > 0) {
      this._actionModel.prompts = this._prompts;
    }
    return this;
  }
  region(...value) {
    this._regions = value;
    if (this._regions.length > 0) {
      this._actionModel.regions = this._regions.map((region) => region.toJson());
    }
    return this;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  removeShadow(value = true) {
    this._removeShadow = value;
    if (this._removeShadow) {
      this._actionModel.removeShadow = this._removeShadow;
    }
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue().setDelimiter(";");
    switch (true) {
      case this._prompts.length > 0: {
        qualifierValue.addValue(this.preparePromptValue());
        break;
      }
      case this._regions.length > 0: {
        qualifierValue.addValue(this.prepareRegionValue());
        break;
      }
    }
    if (this._detectMultiple) {
      qualifierValue.addValue("multiple_true");
    }
    if (this._removeShadow) {
      qualifierValue.addValue("remove-shadow_true");
    }
    this.addQualifier(new Qualifier("e", `gen_remove:${qualifierValue.toString()}`));
  }
  preparePromptValue() {
    const prompts = this._prompts;
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (prompts.length === 1) {
      qualifierValue.addValue(`prompt_${prompts[0]}`);
    } else {
      qualifierValue.addValue(`prompt_(${prompts.join(";")})`);
    }
    return qualifierValue;
  }
  prepareRegionValue() {
    const regions = this._regions;
    const qualifierValue = new QualifierValue();
    if (regions.length === 1) {
      const singleRegion = regions[0].toString();
      qualifierValue.addValue(`region_${singleRegion}`);
    } else {
      const regionList = regions.map((region) => region.toString());
      qualifierValue.addValue(`region_(${regionList.join(";")})`);
    }
    return qualifierValue;
  }
  static fromJson(actionModel) {
    const { prompts, regions, detectMultiple, removeShadow } = actionModel;
    const result = new this();
    if (regions) {
      result.region(...regions.map(({ x, y, width, height }) => new RectangleRegion(x, y, width, height)));
    }
    if (prompts) {
      result.prompt(...prompts);
    }
    if (detectMultiple) {
      result.detectMultiple(detectMultiple);
    }
    if (removeShadow) {
      result.removeShadow(removeShadow);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeReplace.js
var GenerativeReplace = class extends Action {
  constructor() {
    super();
    this._preserveGeometry = false;
    this._detectMultiple = false;
    this._actionModel.actionType = "generativeReplace";
  }
  from(value) {
    this._from = value;
    this._actionModel.from = value;
    return this;
  }
  to(value) {
    this._to = value;
    this._actionModel.to = value;
    return this;
  }
  preserveGeometry(value = true) {
    this._preserveGeometry = value;
    if (value) {
      this._actionModel.preserveGeometry = true;
    }
    return this;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  prepareQualifiers() {
    let str = `gen_replace:from_${this._from};to_${this._to}`;
    if (this._preserveGeometry) {
      str += `;preserve-geometry_true`;
    }
    if (this._detectMultiple) {
      str += `;multiple_true`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { from, to, preserveGeometry, detectMultiple } = actionModel;
    const result = new this();
    result.from(from);
    result.to(to);
    if (preserveGeometry) {
      result.preserveGeometry();
    }
    if (detectMultiple) {
      result.detectMultiple();
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeRecolor.js
var GenerativeRecolor = class extends Action {
  constructor(prompts, color2) {
    super();
    this._prompts = [];
    this._detectMultiple = false;
    this.multiple = this.detectMultiple.bind(this);
    this._prompts = Array.isArray(prompts) ? prompts : [prompts];
    this._toColor = color2;
    this._actionModel.actionType = "generativeRecolor";
    this._actionModel.prompts = this._prompts;
    this._actionModel.toColor = this._toColor;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (this._prompts.length) {
      qualifierValue.addValue(this.preparePromptValue());
    }
    if (this._toColor) {
      const formattedColor = this._toColor.match(/^#/) ? this._toColor.substr(1) : this._toColor;
      qualifierValue.addValue(`to-color_${formattedColor}`);
    }
    if (this._detectMultiple) {
      qualifierValue.addValue("multiple_true");
    }
    this.addQualifier(new Qualifier("e", `gen_recolor:${qualifierValue.toString()}`));
  }
  preparePromptValue() {
    const prompts = this._prompts;
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (prompts.length === 1) {
      qualifierValue.addValue(`prompt_${prompts[0]}`);
    } else {
      qualifierValue.addValue(`prompt_(${prompts.join(";")})`);
    }
    return qualifierValue;
  }
  static fromJson(actionModel) {
    const { prompts, detectMultiple, toColor } = actionModel;
    const result = new this(prompts, toColor);
    if (detectMultiple) {
      result.detectMultiple(detectMultiple);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeBackgroundReplace.js
var GenerativeBackgroundReplace = class extends Action {
  constructor() {
    super();
    this._actionModel.actionType = "generativeBackgroundReplace";
  }
  prompt(value) {
    try {
      this._actionModel.prompt = decodeURIComponent(value);
    } catch (_a) {
      this._actionModel.prompt = value;
    }
    this._prompt = value;
    return this;
  }
  prepareQualifiers() {
    if (!this._prompt) {
      this.addQualifier(new Qualifier("e", "gen_background_replace"));
    } else {
      this.addQualifier(new Qualifier("e", `gen_background_replace:prompt_${encodePromptComponent(this._prompt)}`));
    }
  }
  static fromJson(actionModel) {
    const { prompt } = actionModel;
    const result = new this();
    return result.prompt(prompt);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Extract.js
var Extract = class extends Action {
  constructor(prompts) {
    super();
    this._prompts = [];
    this._detectMultiple = false;
    this._invert = false;
    this._preserveAlpha = false;
    this._actionModel.actionType = "extract";
    this._prompts = Array.isArray(prompts) ? prompts : [prompts];
    this._actionModel.prompts = this._prompts;
  }
  detectMultiple(value = false) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  mode(mode2) {
    this._mode = mode2;
    this._actionModel.mode = this._mode;
    return this;
  }
  invert(value = true) {
    this._invert = value;
    if (this._invert) {
      this._actionModel.invert = this._invert;
    }
    return this;
  }
  preserveAlpha(value = true) {
    this._preserveAlpha = value;
    if (this._preserveAlpha) {
      this._actionModel.preserveAlpha = this._preserveAlpha;
    }
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (this._prompts.length) {
      qualifierValue.addValue(this.preparePromptValue());
    }
    if (this._detectMultiple) {
      qualifierValue.addValue("multiple_true");
    }
    if (this._mode) {
      qualifierValue.addValue(`mode_${this._mode}`);
    }
    if (this._invert) {
      qualifierValue.addValue("invert_true");
    }
    if (this._preserveAlpha) {
      qualifierValue.addValue("preserve-alpha_true");
    }
    this.addQualifier(new Qualifier("e", `extract:${qualifierValue.toString()}`));
  }
  preparePromptValue() {
    const prompts = this._prompts;
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (prompts.length === 1) {
      qualifierValue.addValue(`prompt_${prompts[0]}`);
    } else {
      qualifierValue.addValue(`prompt_(${prompts.join(";")})`);
    }
    return qualifierValue;
  }
  static fromJson(actionModel) {
    const { prompts, detectMultiple, mode: mode2, invert, preserveAlpha } = actionModel;
    const result = new this(prompts);
    if (detectMultiple) {
      result.detectMultiple(detectMultiple);
    }
    if (mode2) {
      result.mode(mode2);
    }
    if (invert) {
      result.invert(invert);
    }
    if (preserveAlpha) {
      result.preserveAlpha(preserveAlpha);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/reshape/TrimAction.js
var TrimAction = class _TrimAction extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "trim"
    };
  }
  /**
   * @param {number} tolerance The tolerance level for color similarity.
   */
  colorSimilarity(tolerance) {
    this._tolerance = tolerance;
    this._actionModel.colorSimilarity = tolerance;
    return this;
  }
  /**
   * @param {string | Qualifiers.Color} color Overrides the corner pixels color with the specified color.
   */
  colorOverride(color2) {
    this._color = color2;
    this._actionModel.colorOverride = color2;
    return this;
  }
  static fromJson(actionModel) {
    const { colorSimilarity, colorOverride } = actionModel;
    const action = new _TrimAction();
    action.colorSimilarity(colorSimilarity);
    action.colorOverride(colorOverride);
    return action;
  }
  toString() {
    return [
      "e_trim",
      this._tolerance,
      this._color
    ].join(":");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect.js
function blur(blurLevel) {
  return new BlurAction(blurLevel);
}
function grayscale() {
  return new SimpleEffectAction("grayscale");
}
function sepia(level) {
  return new EffectActionWithLevel("sepia", level);
}
function shadow(shadowLevel) {
  return new ShadowEffectAction("shadow", shadowLevel);
}
function colorize(colorizeLevel) {
  return new ColorizeEffectAction("colorize", colorizeLevel);
}
function oilPaint(oilPaintLevel) {
  return new EffectActionWithStrength("oil_paint", oilPaintLevel);
}
function artisticFilter(artisticFilterType) {
  return new SimpleEffectAction("art", artisticFilterType);
}
function cartoonify(cartoonifyLevel) {
  return new CartoonifyEffect("cartoonify", cartoonifyLevel);
}
function outline() {
  return new EffectOutline();
}
function styleTransfer(imageSource) {
  return new StyleTransfer(imageSource);
}
function boomerang() {
  return new SimpleEffectAction("boomerang");
}
function advancedRedEye() {
  return new SimpleEffectAction("adv_redeye");
}
function blackwhite(level) {
  return new BlackwhiteEffectAction("blackwhite", level);
}
function negate() {
  return new SimpleEffectAction("negate");
}
function redEye() {
  return new SimpleEffectAction("redeye");
}
function reverse() {
  return new SimpleEffectAction("reverse");
}
function accelerate(speedIncreasePercent) {
  return new AccelerationEffectAction(speedIncreasePercent);
}
function fadeIn(fadeLength) {
  return new FadeInEffectAction(fadeLength);
}
function fadeOut(fadeLength) {
  return new FadeOutEffectAction(fadeLength);
}
function loop(additionalLoops) {
  return new LoopEffectAction("loop", additionalLoops);
}
function makeTransparent(tolerance) {
  return new MakeTransparentEffectAction("make_transparent", tolerance);
}
function noise(percentage) {
  return new EffectActionWithLevel("noise", percentage);
}
function vignette(strength) {
  return new EffectActionWithStrength("vignette", strength);
}
function dither(ditherType) {
  return new DitherEffectAction("ordered_dither", ditherType);
}
function vectorize() {
  return new VectorizeEffectAction();
}
function gradientFade() {
  return new GradientFadeEffectAction();
}
function assistColorBlind() {
  return new AssistColorBlindEffectAction();
}
function simulateColorBlind() {
  return new SimulateColorBlindEffectAction();
}
function deshake(pixels) {
  return new DeshakeEffectAction("deshake", pixels);
}
function transition() {
  return new SimpleEffectAction("transition");
}
function pixelate(squareSize) {
  return new Pixelate(squareSize);
}
function removeBackground() {
  return new RemoveBackgroundAction();
}
function backgroundRemoval() {
  return new BackgroundRemoval();
}
function dropShadow() {
  return new DropShadow();
}
function generativeRemove() {
  return new GenerativeRemove();
}
function generativeReplace() {
  return new GenerativeReplace();
}
function generativeBackgroundReplace() {
  return new GenerativeBackgroundReplace();
}
function extract(prompts) {
  return new Extract(prompts);
}
function generativeRecolor(prompts, color2) {
  return new GenerativeRecolor(prompts, color2);
}
function generativeRestore() {
  return new SimpleEffectAction("gen_restore");
}
function upscale() {
  return new SimpleEffectAction("upscale");
}
function theme(color2) {
  return new ThemeEffect(color2);
}
function enhance() {
  return new SimpleEffectAction("enhance");
}
function trim(colorSimilarity, colorOverride) {
  const trimAction = new TrimAction();
  if (colorSimilarity) {
    trimAction.colorSimilarity(colorSimilarity);
  }
  if (colorOverride) {
    trimAction.colorOverride(colorOverride);
  }
  return trimAction;
}
var Effect = {
  pixelate,
  deshake,
  boomerang,
  advancedRedEye,
  blackwhite,
  negate,
  redEye,
  reverse,
  accelerate,
  fadeIn,
  fadeOut,
  loop,
  makeTransparent,
  noise,
  vignette,
  blur,
  grayscale,
  sepia,
  shadow,
  colorize,
  oilPaint,
  artisticFilter,
  cartoonify,
  outline,
  styleTransfer,
  gradientFade,
  vectorize,
  assistColorBlind,
  simulateColorBlind,
  transition,
  dither,
  removeBackground,
  backgroundRemoval,
  dropShadow,
  generativeRemove,
  generativeReplace,
  generativeBackgroundReplace,
  generativeRecolor,
  generativeRestore,
  upscale,
  theme,
  enhance,
  extract,
  trim
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate/RotateAction.js
var QUALIFIER_KEY = "a";
var RotateAction = class extends Action {
  constructor(angle) {
    super();
    this._actionModel = {};
    this.addQualifier(new Qualifier(QUALIFIER_KEY, angle));
    if (angle) {
      this._actionModel.actionType = "rotateByAngle";
      this._actionModel.angle = angle;
    }
  }
  /**
   * @description Rotates an asset using a defined mode.
   * @param {Qualifiers.RotationMode | RotationModeType | string} rotationMode
   * For a list of supported rotation modes see {@link Qualifiers.RotationMode| types of rotation modes} for
   * possible values
   * @return {this}
   */
  mode(rotationMode) {
    this._actionModel.actionType = "rotateByMode";
    this._actionModel.mode = rotationMode;
    return this.addValueToQualifier(QUALIFIER_KEY, rotationMode);
  }
  /**
   * @description Rotates an asset by the specified degrees.
   * @param {number} degrees rotation in degrees e.g 90, 45, 33
   * @return {this}
   */
  angle(degrees) {
    this._actionModel.actionType = "rotateByAngle";
    this._actionModel.angle = degrees;
    return this.addValueToQualifier(QUALIFIER_KEY, degrees);
  }
  static fromJson(actionModel) {
    const { angle, mode: mode2 } = actionModel;
    const result = mode2 ? new this().mode(mode2) : new this(angle);
    return result;
  }
};
var RotateAction_default = RotateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate.js
function mode(rotationMode) {
  return new RotateAction_default().mode(rotationMode);
}
function byAngle(angle) {
  return new RotateAction_default(angle);
}
var Rotate = { byAngle, mode };

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/FillLightAction.js
var FillLightAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Sets the level of adjustment
   * @param {number} lvl How much to blend the adjusted fill light, where 0 means only use the original and 100 means only use the adjusted fill light result. (Range: 0 to 100, Server default: 100)
   */
  blend(blend) {
    this.lvl = blend;
    return this;
  }
  /**
   * @description Sets the level of the bias
   * @param {number} biasLvl The bias to apply to the fill light effect (Range: -100 to 100, Server default: 0).
   */
  bias(biasLvl) {
    this.biasLvl = biasLvl;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["fill_light", this.lvl, this.biasLvl]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/RecolorAction.js
var RecolorAction = class extends Action {
  constructor(recolorMatrix) {
    super();
    this.matrix = recolorMatrix;
    const flat = [];
    for (let row = 0; row < recolorMatrix.length; row++) {
      for (let col = 0; col < recolorMatrix[row].length; col++) {
        flat.push(recolorMatrix[row][col].toString());
      }
    }
    const qualifierValue = new QualifierValue(["recolor", ...flat]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/OpacityAdjustAction.js
var OpacityAdjustAction = class extends Action {
  constructor(level) {
    super();
    this._actionModel = { actionType: "opacity" };
    this.level = level;
    this._actionModel.level = level;
    this.addQualifier(new Qualifier("o", level));
  }
  static fromJson(actionModel) {
    const { level } = actionModel;
    return new this(level);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/By3dLutAction.js
var By3dLutAction = class extends Action {
  constructor(publicId) {
    super();
    this.publicId = publicId;
  }
  /**
   * Returns a string representation of the action
   * @return {string}
   */
  toString() {
    return `l_lut:${this.publicId}/fl_layer_apply`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ImproveAction.js
var ImproveAction = class extends Action {
  constructor() {
    super();
    this._actionModel = { actionType: "improve" };
  }
  /**
   *
   * @description The improve mode.
   * @param {Qualifiers.ImproveMode | string} value
   */
  mode(value) {
    this.modeValue = value;
    this._actionModel.mode = value;
    return this;
  }
  /**
   * @description How much to blend the improved result with the original image, where 0 means only use the original and 100 means only use the improved result. (Range: 0 to 100, Server default: 100)
   * @param {number} value
   */
  blend(value) {
    this.blendValue = value;
    this._actionModel.blend = value;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["improve", this.modeValue, this.blendValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { mode: mode2, blend } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    blend && result.blend(blend);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ReplaceColorAction.js
var ReplaceColorAction = class extends Action {
  /**
   * @description Sets the target output color.
   * @param {string} toColor - The HTML name or RGB/A hex code of the target output color.
   */
  constructor(toColor) {
    super();
    this.targetColor = toColor;
  }
  /**
   * @description Sets the tolerance threshold.
   * @param {number} toleranceLevel - The tolerance threshold (a radius in the LAB color space) from the input color, </br>
   *                                  representing the span of colors that should be replaced with a correspondingly adjusted version of the target output color. </br>
   *                                  Larger values result in replacing more colors within the image. </br>
   *                                  The more saturated the original input color, the more a change in value will impact the result (Server default: 50).
   * @return {this}
   */
  tolerance(toleranceLevel) {
    this.toleranceLevel = toleranceLevel;
    return this;
  }
  /**
   * @description Sets the base input color to map.
   * @param {string} baseColor - The HTML name or RGB/A hex code of the base input color to map (Server default: the most prominent high-saturation color in the image).
   * @return {this}
   */
  fromColor(baseColor) {
    this.baseColor = baseColor;
    return this;
  }
  prepareQualifiers() {
    const targetColor = this.targetColor && this.targetColor.toString().replace("#", "");
    const baseColor = this.baseColor && this.baseColor.toString().replace("#", "");
    const qualifierValue = new QualifierValue(["replace_color", targetColor, this.toleranceLevel, baseColor]);
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ContrastAction.js
var ContrastAction = class extends Action {
  constructor(level) {
    super();
    this._actionModel = { actionType: "contrast" };
    if (level !== void 0) {
      this.level(level);
    }
  }
  /**
   * @description Sets the level of contrast.
   * @param {number} level The level of contrast.
   *                       Range (sigmoidal): -100 to 100. Default: 0.
   *                       Range (linear): 1 to 200. Default: 100.
   */
  level(level) {
    this.levelValue = level;
    this._actionModel.level = level;
    return this;
  }
  /**
   * @description Sets the function type for the contrast effect.
   * @param {string} functionType The function to use for the contrast effect.
   *                              Possible values: 'sigmoidal' (default), 'linear'
   */
  functionType(functionType) {
    this.functionTypeValue = functionType;
    this._actionModel.functionType = functionType;
    return this;
  }
  prepareQualifiers() {
    let qualifierValueStr = "contrast";
    if (this.levelValue !== void 0) {
      if (this.functionTypeValue) {
        qualifierValueStr += `:level_${this.levelValue}`;
      } else {
        qualifierValueStr += `:${this.levelValue}`;
      }
    }
    if (this.functionTypeValue) {
      qualifierValueStr += `;type_${this.functionTypeValue}`;
    }
    const qualifierValue = new QualifierValue(qualifierValueStr);
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { level, functionType } = actionModel;
    const result = new this(level);
    if (functionType) {
      result.functionType(functionType);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithBlend.js
var EffectActionWithBlend = class extends LeveledEffectAction {
  blend(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/simple/ViesusCorrectAdjustAction.js
var ViesusCorrectAdjustAction = class extends Action {
  /**
   * @description Enhances the image without correcting for red eye.
   */
  noRedEye() {
    this._noRedEye = true;
    return this;
  }
  /**
   * @description Applies saturation to the skin tones in the image.
   * @param level The saturation level. (Range: -100 to 100, Server default: 50).
   */
  skinSaturation(level) {
    this._skinSaturation = true;
    if (level) {
      this._skinSaturationLevel = level;
    }
    return this;
  }
  prepareQualifiers() {
    let value = "viesus_correct";
    if (this._noRedEye) {
      value += ":no_redeye";
    }
    if (this._skinSaturation) {
      value += ":skin_saturation";
      if (typeof this._skinSaturationLevel !== "undefined") {
        value += `_${this._skinSaturationLevel}`;
      }
    }
    this.addQualifier(new Qualifier("e", value));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust.js
function tint(value = "") {
  return new SimpleEffectAction("tint", value);
}
function brightness(level) {
  return new EffectActionWithLevel("brightness", level);
}
function viesusCorrect() {
  return new ViesusCorrectAdjustAction();
}
function red(level) {
  return new EffectActionWithLevel("red", level);
}
function sharpen(strength) {
  return new EffectActionWithStrength("sharpen", strength);
}
function saturation(level) {
  return new EffectActionWithLevel("saturation", level);
}
function contrast(level) {
  return new ContrastAction(level);
}
function gamma(level) {
  return new EffectActionWithLevel("gamma", level);
}
function blue(level) {
  return new EffectActionWithLevel("blue", level);
}
function brightnessHSB(level) {
  return new EffectActionWithLevel("brightness_hsb", level);
}
function opacityThreshold(level) {
  return new EffectActionWithLevel("opacity_threshold", level);
}
function autoColor(blend) {
  return new EffectActionWithBlend("auto_color", blend);
}
function autoBrightness(blend) {
  return new EffectActionWithBlend("auto_brightness", blend);
}
function hue(level) {
  return new EffectActionWithLevel("hue", level);
}
function green(level) {
  return new EffectActionWithLevel("green", level);
}
function unsharpMask(strength) {
  return new EffectActionWithStrength("unsharp_mask", strength);
}
function vibrance(strength) {
  return new EffectActionWithStrength("vibrance", strength);
}
function autoContrast(blend) {
  return new EffectActionWithBlend("auto_contrast", blend);
}
function opacity(level) {
  return new OpacityAdjustAction(level);
}
function improve() {
  return new ImproveAction();
}
function replaceColor(toColor) {
  return new ReplaceColorAction(toColor);
}
function recolor(matrix) {
  return new RecolorAction(matrix);
}
function fillLight() {
  return new FillLightAction();
}
function by3dLut(publicId) {
  return new By3dLutAction(publicId);
}
var Adjust = {
  brightness,
  viesusCorrect,
  opacity,
  red,
  sharpen,
  improve,
  saturation,
  contrast,
  gamma,
  green,
  blue,
  brightnessHSB,
  hue,
  autoBrightness,
  autoColor,
  autoContrast,
  vibrance,
  unsharpMask,
  opacityThreshold,
  replaceColor,
  recolor,
  fillLight,
  by3dLut,
  tint
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/underlay.js
function source(source2) {
  return new LayerAction(source2).setLayerType("u");
}
var Underlay = { source };

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation/NamedTransformationAction.js
var NamedTransformationAction = class extends Action {
  /**
   *
   * @param {string} name The name of the named transformation
   */
  constructor(name2) {
    super();
    this.addQualifier(new Qualifier("t", name2));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation.js
function name(name2) {
  return new NamedTransformationAction(name2);
}
var NamedTransformation = { name };

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryQualityAction.js
var DeliveryQualityAction = class extends DeliveryAction {
  /**
   * @param {Qualifiers.Quality} qualityValue a Quality value
   */
  constructor(qualityValue) {
    super("q", qualityValue.toString(), "level");
  }
  /**
   * Selet the Chroma sub sampling</br>
   * <b>Learn more</b>: {@link https://cloudinary.com/documentation/image_optimization#toggle_chroma_subsampling|Toggling chroma subsampling}
   * @param {420 | 444 | number} type The chroma sub sampling type
   */
  chromaSubSampling(type) {
    this._actionModel.chromaSubSampling = CHROMA_VALUE_TO_CHROMA_MODEL_ENUM[type];
    const qualityWithSubSampling = new QualifierValue([this._actionModel.level, type]);
    qualityWithSubSampling.setDelimiter(":");
    return this.addQualifier(new Qualifier("q", qualityWithSubSampling));
  }
  /**
   * Controls the final quality by setting a maximum quantization percentage
   * @param {number} val
   */
  quantization(val) {
    this._actionModel.quantization = val;
    const qualityWithQuantization = new QualifierValue([this._actionModel.level, `qmax_${val}`]).setDelimiter(":");
    return this.addQualifier(new Qualifier("q", qualityWithQuantization));
  }
  static fromJson(actionModel) {
    const { level, chromaSubSampling, quantization } = actionModel;
    const levelType = ACTION_TYPE_TO_QUALITY_MODE_MAP[level] || level;
    const result = new this(levelType);
    if (chromaSubSampling) {
      const chromaValue = CHROMA_MODEL_ENUM_TO_CHROMA_VALUE[chromaSubSampling.toUpperCase()];
      chromaValue && result.chromaSubSampling(+chromaValue);
    }
    quantization && result.quantization(quantization);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryColorSpaceFromICCAction.js
var DeliveryColorSpaceFromICCAction = class extends Action {
  /**
   * @param {string} publicId
   */
  constructor(publicId) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "colorSpaceFromICC";
    this._actionModel.publicId = publicId;
    const qualifierValue = new QualifierValue(["icc", publicId]).setDelimiter(":");
    this.addQualifier(new Qualifier("cs", qualifierValue));
  }
  static fromJson(actionModel) {
    const { publicId } = actionModel;
    return new this(publicId);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryColorSpaceAction.js
var DeliveryColorSpaceAction = class extends Action {
  /**
   * Create a new DeliveryColorSpaceAction
   * @param mode
   */
  constructor(mode2) {
    super();
    this._actionModel = {};
    this._actionModel = {
      actionType: "colorSpace",
      mode: COLOR_SPACE_MODE_TO_COLOR_SPACE_MODEL_MODE_MAP[mode2] || mode2
    };
    this.addQualifier(new Qualifier("cs", ColorSpace[mode2] ? ColorSpace[mode2]() : mode2));
  }
  static fromJson(actionModel) {
    const { mode: mode2 } = actionModel;
    const colorSpaceMode = COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP[mode2] || mode2;
    return new this(colorSpaceMode);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryDPRAction.js
var DeliveryDPRAction = class extends Action {
  /**
   * Create a new DeliveryDPRAction
   * @param dprValue
   */
  constructor(dprValue) {
    super();
    this._actionModel = { actionType: "dpr" };
    const dprAsFloat = toFloatAsString(dprValue);
    this._actionModel.dpr = dprAsFloat;
    this.addQualifier(new Qualifier("dpr", dprAsFloat));
  }
  static fromJson(actionModel) {
    const { dpr: dpr2 } = actionModel;
    return new this(dpr2);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery.js
function format(format2) {
  return new DeliveryFormatAction("f", format2);
}
function dpr(dpr2) {
  return new DeliveryDPRAction(dpr2);
}
function quality(qualityType) {
  return new DeliveryQualityAction(qualityType);
}
function density(value) {
  return new DeliveryAction("dn", value, "density");
}
function defaultImage(publicIdWithExtension) {
  return new DeliveryAction("d", publicIdWithExtension, "defaultImage");
}
function colorSpace(mode2) {
  return new DeliveryColorSpaceAction(mode2);
}
function colorSpaceFromICC(publicId) {
  return new DeliveryColorSpaceFromICCAction(publicId);
}
var Delivery = {
  format,
  dpr,
  density,
  defaultImage,
  colorSpace,
  colorSpaceFromICC,
  quality
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/CustomFunctionAction.js
var CustomFunctionAction = class extends Action {
  /**
   *
   * @param {string} fn The custom function to use, can be a URL or a publicID
   */
  constructor(fn) {
    super();
    this.fn = fn;
  }
  encodeCustomFunctionString(fn) {
    const encodedSource = base64Encode(fn);
    return encodedSource;
  }
  /**
   * Use a WASM as a custom function,
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asWasm() {
    this.mode = "wasm";
    return this;
  }
  /**
   * Use a remote URL as a custom function
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asRemote() {
    this.mode = "remote";
    return this;
  }
  prepareQualifiers() {
    this.encodedFn = this.fn;
    if (this.mode === "remote") {
      this.encodedFn = this.encodeCustomFunctionString(this.fn);
    }
    return this.addQualifier(new Qualifier("fn", new QualifierValue([this.pre, this.mode, this.encodedFn])));
  }
  toString() {
    return super.toString().replace(/\//g, ":");
  }
};
var CustomFunctionAction_default = CustomFunctionAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/RemoteAction.js
var RemoteAction = class extends CustomFunctionAction_default {
  constructor(fn) {
    super(fn);
  }
  preprocess() {
    this.pre = "pre";
    return this;
  }
};
var RemoteAction_default = RemoteAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction.js
function remote(path) {
  return new RemoteAction_default(path).asRemote();
}
function wasm(publicID) {
  return new CustomFunctionAction_default(publicID).asWasm();
}
var CustomFunction = { remote, wasm };

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/TrimAction.js
var TrimAction2 = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "trimVideo"
    };
  }
  /**
   *
   * @description Support Percentages in values (30% -> 30p)
   * @param {string|number} val
   * @private
   * @return {string}
   */
  parseVal(val) {
    return typeof val === "number" ? val : val.replace("%", "p");
  }
  /**
   * @description Sets the starting position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The starting position of the part of the video to keep. This can be specified as a
   *                           float representing the time in seconds or a string representing the percentage of the
   *                           video length (for example, "30%" or "30p").
   * @return {this}
   */
  startOffset(offset) {
    this._actionModel.startOffset = getAuto(offset) || +offset;
    return this.addQualifier(new Qualifier("so", this.parseVal(offset)));
  }
  /**
   * @description Sets the end position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The end position of the part of the video to keep. This can be specified as a
   *                         float representing the time in seconds or a string representing the percentage of the
   *                         video length (for example, "30%" or "30p").
   * @return {this}
   */
  endOffset(offset) {
    this._actionModel.endOffset = getAuto(offset) || +offset;
    return this.addQualifier(new Qualifier("eo", this.parseVal(offset)));
  }
  /**
   * @description Sets the duration of the video to keep.
   *
   * @param {string|number} duration The length of the part of the video to keep. This can be specified as a float
   *                        representing the time in seconds or a string representing the percentage of the
   *                        video length (for example, "30%" or "30p").
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = duration;
    return this.addQualifier(new Qualifier("du", this.parseVal(duration)));
  }
  static fromJson(actionModel) {
    const { duration, startOffset, endOffset } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (startOffset != null) {
      result.startOffset(startOffset);
    }
    if (endOffset != null) {
      result.endOffset(endOffset);
    }
    return result;
  }
};
var getAuto = (value) => value === "auto" ? value : null;
var TrimAction_default = TrimAction2;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/ConcatenateAction.js
var ConcatenateAction = class extends Action {
  /**
   *
   * @param {Qualifiers.Source.VideoSource | Qualifiers.Source.ImageSource | Qualifiers.Source.FetchSource} source
   *         the Source to concatenate
   */
  constructor(source2) {
    super();
    this._actionModel = {
      actionType: "concatenate",
      source: source2.toJson()
    };
    this.concatSource = source2;
  }
  /**
   * @description Sets the transition between a video and a concatenated source
   * @param {Qualifiers.Transition.VideoSource} source The source to concatenate.
   * @return {this}
   */
  transition(source2) {
    this._actionModel.transition = source2.toJson();
    this._transition = source2;
    return this;
  }
  /**
   * @description Prepend the concatenated video - Adds the video before the original
   * @return {this}
   */
  prepend() {
    this._actionModel.prepend = true;
    this._prepend = true;
    return this;
  }
  /**
   * The duration in seconds
   * @param {number} sec
   * @return {this}
   */
  duration(sec) {
    this._actionModel.duration = sec;
    this._duration = sec;
    return this;
  }
  /**
   * @description Get the transitionString for the toString() method
   * @return {string}
   */
  getTransitionString() {
    const transTx = this._transition.getTransformation();
    return [
      `e_transition,${this._transition.getOpenSourceString("l")}`,
      transTx && transTx.toString(),
      "fl_layer_apply"
    ].filter((a) => a).join("/");
  }
  /**
   * @description Get the string representation of the Concatenation action
   */
  toString() {
    const open = [
      this._duration && `du_${this._duration}`,
      !this._transition && `fl_splice`,
      `${this.concatSource.getOpenSourceString("l")}`
    ].filter((a) => a).join(",");
    const close = [
      "fl_layer_apply",
      this._prepend && "so_0"
    ].filter((a) => a).join(",");
    let concatSourceTx;
    if (this.concatSource.getTransformation()) {
      concatSourceTx = this.concatSource.getTransformation();
    } else {
      concatSourceTx = new Transformation();
    }
    if (this._transition) {
      concatSourceTx.addTransformation(this.getTransitionString());
    }
    return [
      open,
      concatSourceTx.toString(),
      close
    ].filter((a) => a).join("/");
  }
  static fromJson(actionModel, transformationFromJson) {
    const { source: source2, transition: transition2, prepend, duration } = actionModel;
    const sourceInstance = createSourceFromModel(source2, transformationFromJson);
    const result = new this(sourceInstance);
    if (transition2) {
      result.transition(VideoSource.fromJson(transition2, transformationFromJson));
    }
    if (prepend) {
      result.prepend();
    }
    if (duration) {
      result.duration(duration);
    }
    return result;
  }
};
var ConcatenateAction_default = ConcatenateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/VolumeAction.js
var VolumeAction = class extends Action {
  constructor(volumeValue) {
    super();
    let volumeValueModel = { mode: "mute" };
    if (volumeValue !== "mute") {
      volumeValueModel = {
        mode: `${volumeValue}`.endsWith("db") ? "decibels" : "percent",
        value: +`${volumeValue}`.replace("db", "")
      };
    }
    this._actionModel = {
      actionType: "volume",
      volumeValue: volumeValueModel
    };
    const qualifierValue = new QualifierValue(["volume", volumeValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
  static fromJson(actionModel) {
    const { volumeValue } = actionModel;
    const { mode: mode2 } = volumeValue;
    const value = mode2 === "mute" ? mode2 : volumeValue.value;
    const suffix = mode2 === "mute" || mode2 === "percent" ? "" : "db";
    return new this(`${value}${suffix}`);
  }
};
var VolumeAction_default = VolumeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/PreviewAction.js
var PreviewAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "preview"
    };
  }
  /**
   * @description Control the duration of the video segments
   * @param {string|number} minSegDuration The duration of a video segment
   * @return {this}
   */
  minimumSegmentDuration(minSegDuration) {
    this._actionModel.minimumSegmentDuration = +minSegDuration;
    this._minSeg = minSegDuration;
    return this;
  }
  /**
   * @description Control the number of the video segments
   * @param {string|number} maxSeg The number of the video segments.
   * @return {this}
   */
  maximumSegments(maxSeg) {
    this._actionModel.maximumSegments = +maxSeg;
    this._maxSeg = maxSeg;
    return this;
  }
  /**
   * @description control the length of the generated preview
   * @param {string|number} duration The duration in seconds such as 1.2, or 5.0
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = +duration;
    this._duration = duration;
    return this;
  }
  toString() {
    return [
      "e_preview",
      this._duration && `duration_${toFloatAsString(this._duration)}`,
      this._maxSeg && `max_seg_${this._maxSeg}`,
      this._minSeg && `min_seg_dur_${toFloatAsString(this._minSeg)}`
    ].filter((a) => a).join(":");
  }
  static fromJson(actionModel) {
    const { duration, maximumSegments, minimumSegmentDuration } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (maximumSegments != null) {
      result.maximumSegments(maximumSegments);
    }
    if (minimumSegmentDuration != null) {
      result.minimumSegmentDuration(minimumSegmentDuration);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit.js
function concatenate(source2) {
  return new ConcatenateAction_default(source2);
}
function trim2() {
  return new TrimAction_default();
}
function volume(volumeValue) {
  return new VolumeAction_default(volumeValue);
}
function preview() {
  return new PreviewAction();
}
var VideoEdit = { concatenate, trim: trim2, volume, preview };

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/BitRateAction.js
var BitRateAction = class extends Action {
  constructor(bitRate2) {
    super();
    this.isConstant = false;
    this._actionModel = { actionType: "bitRate" };
    this.bitRate = bitRate2;
    this._actionModel.bitRate = bitRate2;
  }
  /**
   * @description video plays with a constant bitrate (CBR).
   */
  constant() {
    this.isConstant = true;
    this._actionModel.constant = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.isConstant) {
      qualifierValue = new QualifierValue([this.bitRate, "constant"]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.bitRate);
    }
    this.addQualifier(new Qualifier("br", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { bitRate: bitRate2, constant } = actionModel;
    const result = new this(bitRate2);
    constant && result.constant();
    return result;
  }
};
var BitRateAction_default = BitRateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioCodecAction.js
var AudioCodecAction = class extends Action {
  constructor(codec) {
    super();
    this._actionModel = { actionType: "audioCodec" };
    this.addQualifier(new Qualifier("ac", codec));
    this._actionModel.audioCodec = codec;
  }
  static fromJson(actionModel) {
    const { audioCodec: audioCodec2 } = actionModel;
    const result = new this(audioCodec2);
    return result;
  }
};
var AudioCodecAction_default = AudioCodecAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioFrequencyAction.js
var AudioFrequencyAction = class extends Action {
  constructor(freq) {
    super();
    this._actionModel = { actionType: "audioFrequency" };
    this.addQualifier(new Qualifier("af", freq));
    this._actionModel.audioFrequencyType = freq;
  }
  static fromJson(actionModel) {
    const { audioFrequencyType } = actionModel;
    const result = new this(audioFrequencyType.replace("freq", ""));
    return result;
  }
};
var AudioFrequencyAction_default = AudioFrequencyAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSRangeAction.js
var FPSRangeAction = class extends Action {
  constructor(from, to) {
    super();
    this._actionModel = {};
    this.from = from;
    this._actionModel = {
      actionType: "fps",
      fps: { from }
    };
    if (to != null) {
      this.to = to;
      this._actionModel.fps.to = to;
    }
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.from && this.to) {
      qualifierValue = new QualifierValue(`${this.from}-${this.to}`);
    } else {
      qualifierValue = new QualifierValue(`${this.from}-`);
    }
    this.addQualifier(new Qualifier("fps", qualifierValue));
    return this;
  }
};
var FPSRangeAction_default = FPSRangeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSAction.js
var FPSAction = class extends Action {
  constructor(from) {
    super();
    this._actionModel = { actionType: "fps" };
    this._actionModel.fps = from;
    this.addQualifier(new Qualifier("fps", from));
  }
  static fromJson(actionModel) {
    const { fps: fps2 } = actionModel;
    let result;
    if (typeof fps2 === "object") {
      result = new FPSRangeAction_default(fps2.from, fps2.to);
    } else {
      result = new this(fps2);
    }
    return result;
  }
};
var FPSAction_default = FPSAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/KeyframeIntervalsAction.js
var KeyframeIntervalsAction = class extends Action {
  constructor(interval) {
    super();
    this._actionModel = { actionType: "keyframeInterval" };
    this._actionModel.interval = interval;
    this.addQualifier(new Qualifier("ki", toFloatAsString(interval)));
  }
  static fromJson(actionModel) {
    const { interval } = actionModel;
    const result = new this(interval);
    return result;
  }
};
var KeyframeIntervalsAction_default = KeyframeIntervalsAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/StreamingProfile.js
var StreamingProfileAction = class extends Action {
  constructor(profile) {
    super();
    this._actionModel = { actionType: "streamingProfile" };
    this.addQualifier(new Qualifier("sp", profile));
    this._actionModel.profile = STREAMING_PROFILE_TO_ACTION_TYPE_MAP[profile] || profile;
  }
  static fromJson(actionModel) {
    const { profile } = actionModel;
    const profileType = ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP[profile] || profile;
    const result = new this(profileType);
    return result;
  }
};
var StreamingProfile_default = StreamingProfileAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/ToAnimatedAction.js
var ToAnimatedAction = class extends Action {
  constructor(animatedFormat = "") {
    super();
    this._actionModel = { actionType: "toAnimated" };
    if (animatedFormat.toString() === "webp") {
      this.addFlag(animatedWebP());
    }
    this.addFlag(animated());
    if (animatedFormat) {
      this.addQualifier(new Qualifier("f", animatedFormat));
    }
    this._actionModel.animatedFormat = animatedFormat;
  }
  /**
   * @description Sets the time between frames.
   * @param delayValue The time in milliseconds.
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    this._actionModel.delay = delayValue;
    return this;
  }
  /**
   * @description Sets the frequency at which the video is sampled.
   * @param sampling As a string (e.g. '2.3s'), samples one frame every 2.3 seconds.<br>As a number (e.g. 20),
   * samples that many equally spaced frames over the duration of the video.
   */
  sampling(sampling) {
    this.addQualifier(new Qualifier("vs", sampling));
    this._actionModel.sampling = sampling;
    return this;
  }
  static fromJson(actionModel) {
    const { animatedFormat, sampling, delay } = actionModel;
    const result = new this(animatedFormat);
    sampling && result.sampling(sampling);
    delay && result.delay(delay);
    return result;
  }
};
var ToAnimatedAction_default = ToAnimatedAction;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodecType/VideoCodecType.js
var VideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
    this.addValue(type);
  }
  getType() {
    return this._type;
  }
};
var AdvVideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
  }
  getType() {
    return this._type;
  }
  /**
   * @description Specifies the profile to use with the h264 codec.
   * @param {Qualifiers.VideoCodecProfile | string} profile Sets the profile of the video codec
   * @example new AdvVideoCodecType('h264').profile(VideoCodecProfile.baseline())
   * @return this;
   */
  profile(profile) {
    this._prof = profile;
    return this;
  }
  getProfile() {
    return this._prof;
  }
  /**
   * @description Specifies the level to use with the h264 codec and specified profile.
   * @param {Qualifiers.VideoCodecLevel | number | string} lvl
   * @example new AdvVideoCodecType('h264').profile(VideoCodecLevel.baseline())
   * @return this;
   */
  level(lvl) {
    this._lvl = lvl;
    return this;
  }
  getLevel() {
    return this._lvl;
  }
  /**
   * @description returns a toString representation of this qualifier
   * @return string;
   */
  toString() {
    return `vc_${this._type}:${this._prof}:${this._lvl}`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodec.js
function auto3() {
  return new VideoCodecType("auto");
}
function h264() {
  return new AdvVideoCodecType("h264");
}
function h265() {
  return new VideoCodecType("h265");
}
function proRes() {
  return new VideoCodecType("prores");
}
function theora() {
  return new VideoCodecType("theora");
}
function vp8() {
  return new VideoCodecType("vp8");
}
function vp9() {
  return new VideoCodecType("vp9");
}
var VIDEO_CODEC_TO_TRANSFORMATION = {
  "auto": auto3(),
  "h264": h264(),
  "h265": h265(),
  "prores": proRes(),
  "theora": theora(),
  "vp8": vp8(),
  "vp9": vp9()
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/VideoCodecAction.js
var VideoCodecAction = class extends Action {
  constructor(videoCodecTypeQualifier) {
    super();
    this._actionModel = { actionType: "videoCodec" };
    this._actionModel.videoCodec = { videoCodecName: videoCodecTypeQualifier.getType() };
    if (videoCodecTypeQualifier instanceof AdvVideoCodecType) {
      if (videoCodecTypeQualifier.getProfile()) {
        this._actionModel.videoCodec = Object.assign({ profile: videoCodecTypeQualifier.getProfile() }, this._actionModel.videoCodec);
      }
      if (videoCodecTypeQualifier.getLevel()) {
        this._actionModel.videoCodec = Object.assign({ level: videoCodecTypeQualifier.getLevel() }, this._actionModel.videoCodec);
      }
    }
    this.addQualifier(videoCodecTypeQualifier);
  }
  static fromJson(actionModel) {
    const { videoCodec: videoCodec2 } = actionModel;
    const result = new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName]);
    videoCodec2.profile && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].profile(videoCodec2.profile));
    videoCodec2.level && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].level(videoCodec2.level));
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode.js
function audioFrequency(freq) {
  return new AudioFrequencyAction_default(freq);
}
function audioCodec(codec) {
  return new AudioCodecAction_default(codec);
}
function bitRate(bitRate2) {
  return new BitRateAction_default(bitRate2);
}
function fps(from) {
  return new FPSAction_default(from);
}
function fpsRange(from, to) {
  return new FPSRangeAction_default(from, to);
}
function keyframeInterval(interval) {
  return new KeyframeIntervalsAction_default(interval);
}
function streamingProfile(profile) {
  return new StreamingProfile_default(profile);
}
function toAnimated(animatedFormat = "") {
  return new ToAnimatedAction_default(animatedFormat);
}
function videoCodec(videoCodecType) {
  return new VideoCodecAction(videoCodecType);
}
var Transcode = { bitRate, audioCodec, audioFrequency, fps, fpsRange, keyframeInterval, streamingProfile, toAnimated, videoCodec };

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/ClipAction.js
var ClipAction = class extends Action {
  constructor() {
    super();
    this.isEvenOdd = false;
  }
  /**
   * @description The name of the path to clip by
   * @param {string} path
   * @return {this}
   */
  byName(path) {
    this.path = path;
    return this;
  }
  /**
   * @description The index of the path to clip by
   * @param {number} path
   * @return {this}
   */
  byIndex(path) {
    this.path = path;
    return this;
  }
  /**
   * @description Trims pixels according to a clipping path included in the original image using an evenodd clipping rule.
   * @return {this}
   */
  evenOdd() {
    this.isEvenOdd = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (typeof this.path === "string") {
      qualifierValue = new QualifierValue(["name", this.path]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.path);
    }
    if (this.isEvenOdd) {
      this.addFlag(clipEvenOdd());
    } else {
      this.addFlag(clip());
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/GetLayerAction.js
var GetLayerAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description deliver an image containing only specified layer of a Photoshop image from The layer index
   * @param {string|number} from the index of the layer
   */
  byIndex(from) {
    this.qualifierValue.addValue(from);
    return this;
  }
  /**
   * @description deliver an image containing only specified range of layers of a Photoshop image
   * @param {string|number} from The layer number
   * @param {string|number} to The layer number
   */
  byRange(from, to) {
    const range = new QualifierValue(from);
    range.addValue(to);
    range.delimiter = "-";
    this.qualifierValue.addValue(range);
    return this;
  }
  /**
   * @description deliver an image containing only specified layer by name of a Photoshop image
   * @param {string|number} name The layer by name
   */
  byName(name2) {
    this.name = name2;
    this.qualifierValue.addValue(name2);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue = this.qualifierValue;
    if (this.name) {
      qualifierValue = new QualifierValue(["name", this.qualifierValue]).setDelimiter(":");
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/SmartObjectAction.js
var SmartObjectAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.useName = false;
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description Creates a new instance using the specified number.
   * @param index The number.
   */
  byIndex(index) {
    this.smartObjectValue = index;
    this.qualifierValue.addValue(index);
    return this;
  }
  /**
   * @description Creates an instance using the name.
   * @param {string} layerName The name of the layer
   */
  byLayerName(layerName) {
    this.useName = true;
    this.qualifierValue.addValue(layerName);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.useName) {
      qualifierValue = new QualifierValue(["embedded:name", this.qualifierValue]);
    } else {
      qualifierValue = new QualifierValue(["embedded", this.qualifierValue]);
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools.js
function clip2() {
  return new ClipAction();
}
function getLayer() {
  return new GetLayerAction();
}
function smartObject() {
  return new SmartObjectAction();
}
var PSDTools = { clip: clip2, getLayer, smartObject };

// node_modules/@cloudinary/transformation-builder-sdk/actions/animated.js
var AnimatedAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Controls the time delay between the frames of an animated image, in milliseconds.
   * @param {number} delayValue The delay in milliseconds
   * @return {this}
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    return this;
  }
  /**
   * @description Delivers an animated GIF that contains additional loops of the GIF.
   * @param {number} additionalLoops The additional number of times to play the animated GIF.
   * @return {this}
   */
  loop(additionalLoops) {
    const qualifierValue = new QualifierValue(["loop", additionalLoops]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};
function edit() {
  return new AnimatedAction();
}
var Animated = {
  edit
};

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/isUrl.js
function isUrl(publicID) {
  return publicID.match(/^https?:\//);
}

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/isFileName.js
function isFileName(publicID) {
  return publicID.indexOf("/") < 0;
}

// node_modules/@cloudinary/url-gen/internal/url/urlUtils/publicIDContainsVersion.js
function publicIDContainsVersion(publicID) {
  return publicID.match(/^v[0-9]+/);
}

// node_modules/@cloudinary/url-gen/internal/url/cloudinaryURL.js
function getUrlPrefix(cloudName, urlConfig) {
  const secure = urlConfig.secure;
  const privateCDN = urlConfig.privateCdn;
  const cname = urlConfig.cname;
  const secureDistribution = urlConfig.secureDistribution;
  if (!secure && !cname) {
    return `http://res.cloudinary.com/${cloudName}`;
  }
  if (secure && !secureDistribution && privateCDN) {
    return `https://${cloudName}-res.cloudinary.com`;
  }
  if (secure && !secureDistribution) {
    return `https://res.cloudinary.com/${cloudName}`;
  }
  if (secure && secureDistribution && privateCDN) {
    return `https://${secureDistribution}`;
  }
  if (secure && secureDistribution) {
    return `https://${secureDistribution}/${cloudName}`;
  }
  if (!secure && cname) {
    return `http://${cname}/${cloudName}`;
  } else {
    return "ERROR";
  }
}
function handleAssetType(assetType) {
  if (!assetType) {
    return "image";
  }
  return assetType;
}
function handleDeliveryType(deliveryType) {
  if (!deliveryType) {
    return "upload";
  }
  return deliveryType;
}
function getUrlVersion(publicID, version, forceVersion) {
  const shouldForceVersion = forceVersion !== false;
  if (version) {
    return `v${version}`;
  }
  if (publicIDContainsVersion(publicID) || isUrl(publicID) || isFileName(publicID)) {
    return "";
  }
  return shouldForceVersion ? "v1" : "";
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/stringPad.js
function stringPad(value, _targetLength, _padString) {
  let targetLength = _targetLength >> 0;
  let padString = String(typeof _padString !== "undefined" ? _padString : " ");
  if (value.length > targetLength) {
    return String(value);
  } else {
    targetLength = targetLength - value.length;
    if (targetLength > padString.length) {
      padString += repeatStringNumTimes(padString, targetLength / padString.length);
    }
    return padString.slice(0, targetLength) + String(value);
  }
}
function repeatStringNumTimes(string, _times) {
  let times = _times;
  let repeatedString = "";
  while (times > 0) {
    repeatedString += string;
    times--;
  }
  return repeatedString;
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/base64Map.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64Map = {};
var num = 0;
chars.split("").forEach((char) => {
  let key = num.toString(2);
  key = stringPad(key, 6, "0");
  base64Map[key] = char;
  num++;
});

// node_modules/@cloudinary/url-gen/sdkAnalytics/reverseVersion.js
function reverseVersion(semVer) {
  if (semVer.split(".").length < 2) {
    throw new Error("invalid semVer, must have at least two segments");
  }
  return semVer.split(".").reverse().join(".");
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/padVersion.js
function padVersion(semVer) {
  if (semVer.split(".").length < 2) {
    throw new Error("invalid semVer, must have at least two segments");
  }
  return semVer.split(".").map((segment) => {
    const asNumber = +segment;
    if (isNaN(asNumber) || asNumber < 0) {
      throw "Invalid version number provided";
    }
    return stringPad(segment, 2, "0");
  }).join(".");
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/encodeVersion.js
function encodeVersion(semVer) {
  let strResult = "";
  const parts = semVer.split(".").length;
  const paddedStringLength = parts * 6;
  const reversedSemver = reverseVersion(semVer);
  const paddedSemver = padVersion(reversedSemver);
  const num2 = parseInt(paddedSemver.split(".").join(""));
  let paddedBinary = num2.toString(2);
  paddedBinary = stringPad(paddedBinary, paddedStringLength, "0");
  if (paddedBinary.length % 6 !== 0) {
    throw "Version must be smaller than 43.21.26)";
  }
  paddedBinary.match(/.{1,6}/g).forEach((bitString) => {
    strResult += base64Map[bitString];
  });
  return strResult;
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/getAnalyticsOptions.js
function getAnalyticsOptions(options) {
  const analyticsOptions = {
    sdkSemver: options.sdkSemver,
    techVersion: options.techVersion,
    sdkCode: options.sdkCode,
    product: options.product,
    feature: "0",
    osType: options.osType,
    osVersion: options.osVersion
  };
  if (options.accessibility) {
    analyticsOptions.feature = "D";
  }
  if (options.lazyload) {
    analyticsOptions.feature = "C";
  }
  if (options.responsive) {
    analyticsOptions.feature = "A";
  }
  if (options.placeholder) {
    analyticsOptions.feature = "B";
  }
  return analyticsOptions;
}

// node_modules/@cloudinary/url-gen/internal/utils/packageVersion.js
var packageVersion = "1.21.0";

// node_modules/@cloudinary/url-gen/sdkAnalytics/encodeOSVersion.js
function encodeOSVersion(semVer) {
  const [major, minor] = semVer.split(".");
  const binaryMajorVersion = parseInt(major).toString(2);
  const binaryMinorVersion = parseInt(minor).toString(2);
  const paddedMajor = binaryMajorVersion.padStart(6, "0");
  const paddedMinor = binaryMinorVersion.padStart(6, "0");
  return base64Map[paddedMajor] + base64Map[paddedMinor];
}

// node_modules/@cloudinary/url-gen/sdkAnalytics/getSDKAnalyticsSignature.js
function getNodeVersion() {
  const failedVersion = "0.0.0";
  if (typeof window !== "undefined") {
    return failedVersion;
  } else {
    try {
      return process.versions.node || failedVersion;
    } catch (e) {
      return failedVersion;
    }
  }
}
function ensureShapeOfTrackedProperties(trackedAnalytics) {
  const defaults = {
    techVersion: getNodeVersion(),
    sdkCode: "T",
    sdkSemver: packageVersion.split("-")[0],
    product: "A",
    osType: "Z",
    osVersion: "0.0",
    responsive: false,
    placeholder: false,
    lazyload: false,
    accessibility: false
  };
  if (!trackedAnalytics) {
    return defaults;
  } else {
    return Object.assign(Object.assign({}, defaults), trackedAnalytics);
  }
}
function getSDKAnalyticsSignature(_trackedAnalytics) {
  const trackedAnalytics = ensureShapeOfTrackedProperties(_trackedAnalytics);
  const analyticsOptions = getAnalyticsOptions(trackedAnalytics);
  try {
    const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);
    const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);
    const encodedTechVersion = encodeVersion(twoPartVersion);
    const encodedOSVersion = encodeOSVersion(analyticsOptions.osVersion);
    const featureCode = analyticsOptions.feature;
    const SDKCode = analyticsOptions.sdkCode;
    const { product, osType } = analyticsOptions;
    const algoVersion = "D";
    return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${osType}${encodedOSVersion}${featureCode}`;
  } catch (e) {
    return "E";
  }
}
function removePatchFromSemver(semVerStr) {
  const parts = semVerStr.split(".");
  return `${parts[0]}.${parts[1]}`;
}

// node_modules/@cloudinary/url-gen/assets/CloudinaryFile.js
var SEO_TYPES = {
  "image/upload": "images",
  "image/private": "private_images",
  "image/authenticated": "authenticated_images",
  "raw/upload": "files",
  "video/upload": "videos"
};
var CloudinaryFile = class {
  constructor(publicID, cloudConfig = {}, urlConfig) {
    this.setPublicID(publicID);
    this.setCloudConfig(cloudConfig);
    this.setURLConfig(urlConfig);
  }
  /**
   * @description Sets the URL Config for this asset
   * @param urlConfig
   * @return {this}
   */
  setURLConfig(urlConfig) {
    this.urlConfig = new URLConfig_default(urlConfig);
    return this;
  }
  /**
   * @description Sets the Cloud Config for this asset
   * @param urlConfig
   * @return {this}
   */
  setCloudConfig(cloudConfig) {
    this.cloudName = cloudConfig.cloudName;
    this.apiKey = cloudConfig.apiKey;
    this.apiSecret = cloudConfig.apiSecret;
    this.authToken = cloudConfig.authToken;
    return this;
  }
  /**
   * @description Sets the public ID of the asset.
   * @param {string} publicID The public ID of the asset.
   * @return {this}
   */
  setPublicID(publicID) {
    this.publicID = publicID ? publicID.toString() : "";
    return this;
  }
  /**
   * @description Sets the delivery type of the asset.
   * @param {DELIVERY_TYPE | string} newType The type of the asset.
   * @return {this}
   */
  setDeliveryType(newType) {
    this.deliveryType = newType;
    return this;
  }
  /**
   * @description Sets the URL SEO suffix of the asset.
   * @param {string} newSuffix The SEO suffix.
   * @return {this}
   */
  setSuffix(newSuffix) {
    this.suffix = newSuffix;
    return this;
  }
  /**
   * @description Sets the signature of the asset.
   * @param {string} signature The signature.
   * @return {this}
   */
  setSignature(signature) {
    this.signature = signature;
    return this;
  }
  /**
   * @description Sets the version of the asset.
   * @param {string} newVersion The version of the asset.
   * @return {this}
   */
  setVersion(newVersion) {
    if (newVersion) {
      this.version = newVersion;
    }
    return this;
  }
  /**
   * @description Sets the asset type.
   * @param {string} newType The type of the asset.
   * @return {this}
   */
  setAssetType(newType) {
    if (newType) {
      this.assetType = newType;
    }
    return this;
  }
  sign() {
    return this;
  }
  /**
   * @description Serializes to URL string
   * @param overwriteOptions
   */
  toURL(overwriteOptions = {}) {
    return this.createCloudinaryURL(null, overwriteOptions.trackedAnalytics);
  }
  /**
   * @description Validate various options before attempting to create a URL
   * The function will throw in case a violation
   * @throws Validation errors
   */
  validateAssetForURLCreation() {
    if (typeof this.cloudName === "undefined") {
      throw "You must supply a cloudName when initializing the asset";
    }
    const suffixContainsDot = this.suffix && this.suffix.indexOf(".") >= 0;
    const suffixContainsSlash = this.suffix && this.suffix.indexOf("/") >= 0;
    if (suffixContainsDot || suffixContainsSlash) {
      throw "`suffix`` should not include . or /";
    }
  }
  /**
   * @description return an SEO friendly name for a combination of asset/delivery, some examples:
   * * image/upload -> images
   * * video/upload -> videos
   * If no match is found, return `{asset}/{delivery}`
   */
  getResourceType() {
    const assetType = handleAssetType(this.assetType);
    const deliveryType = handleDeliveryType(this.deliveryType);
    const hasSuffix = !!this.suffix;
    const regularSEOType = `${assetType}/${deliveryType}`;
    const shortSEOType = SEO_TYPES[`${assetType}/${deliveryType}`];
    const useRootPath = this.urlConfig.useRootPath;
    const shorten = this.urlConfig.shorten;
    if (useRootPath) {
      if (regularSEOType === "image/upload") {
        return "";
      } else {
        throw new Error(`useRootPath can only be used with assetType: 'image' and deliveryType: 'upload'. Provided: ${regularSEOType} instead`);
      }
    }
    if (shorten && regularSEOType === "image/upload") {
      return "iu";
    }
    if (hasSuffix) {
      if (shortSEOType) {
        return shortSEOType;
      } else {
        throw new Error(`URL Suffix only supported for ${Object.keys(SEO_TYPES).join(", ")}, Provided: ${regularSEOType} instead`);
      }
    }
    return regularSEOType;
  }
  getSignature() {
    if (this.signature) {
      return `s--${this.signature}--`;
    } else {
      return "";
    }
  }
  /**
   *
   * @description Creates a fully qualified CloudinaryURL
   * @return {string} CloudinaryURL
   * @throws Validation Errors
   */
  createCloudinaryURL(transformation, trackedAnalytics) {
    if (!this.publicID) {
      return "";
    }
    this.validateAssetForURLCreation();
    const prefix = getUrlPrefix(this.cloudName, this.urlConfig);
    const transformationString = transformation ? transformation.toString() : "";
    const version = getUrlVersion(this.publicID, this.version, this.urlConfig.forceVersion);
    const publicID = this.publicID;
    if (typeof transformation === "string") {
      const url = [prefix, this.getResourceType(), this.getSignature(), transformationString, version, publicID.replace(/,/g, "%2C"), this.suffix].filter((a) => a).join("/");
      return url;
    } else {
      const safeURL = [
        encodeURI(prefix),
        this.getResourceType(),
        this.getSignature(),
        encodeURI(transformationString),
        version,
        encodeURI(publicID).replace(/,/g, "%2C"),
        this.suffix && encodeURI(this.suffix)
      ].filter((a) => a).join("/").replace(/\?/g, "%3F").replace(/=/g, "%3D");
      const shouldAddAnalytics = this.urlConfig.analytics !== false && !publicID.includes("?");
      let queryParamsString = "";
      if (typeof this.urlConfig.queryParams === "object") {
        try {
          const queryParams = new URLSearchParams(this.urlConfig.queryParams);
          if (shouldAddAnalytics) {
            queryParams.set("_a", getSDKAnalyticsSignature(trackedAnalytics));
          }
          queryParamsString = queryParams.toString();
        } catch (err) {
          console.error("Error: URLSearchParams is not available so the queryParams object cannot be parsed, please try passing as an already parsed string");
        }
      } else {
        queryParamsString = this.urlConfig.queryParams || "";
        if (shouldAddAnalytics) {
          queryParamsString += `${queryParamsString.length > 0 ? "&" : ""}_a=${getSDKAnalyticsSignature(trackedAnalytics)}`;
        }
      }
      if (queryParamsString) {
        return `${safeURL}?${queryParamsString}`;
      } else {
        return safeURL;
      }
    }
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryTransformable.js
var CloudinaryTransformable = class extends CloudinaryFile {
  constructor(publicID, cloudConfig, urlConfig, transformation) {
    super(publicID, cloudConfig, urlConfig);
    this.transformation = transformation;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Animated} animated
   * @return {this}
   */
  animated(animated2) {
    this.transformation.animated(animated2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Border} border
   * @return {this}
   */
  border(border2) {
    this.transformation.border(border2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Reshape} reshape
   * @return {this}
   */
  reshape(reshape) {
    this.transformation.reshape(reshape);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Resize} resize
   * @return {this}
   */
  resize(resize) {
    this.transformation.resize(resize);
    return this;
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality2) {
    this.addAction(new DeliveryFormatAction("q", quality2));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format2) {
    this.addAction(new DeliveryFormatAction("f", format2));
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.RoundCorners} roundCorners
   * @return {this}
   */
  roundCorners(roundCorners2) {
    this.transformation.roundCorners(roundCorners2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {this}
   */
  overlay(overlayAction) {
    this.transformation.overlay(overlayAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Variable} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    this.transformation.addVariable(variableAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Condition} conditionalAction
   * @return {this}
   */
  conditional(conditionalAction) {
    this.transformation.conditional(conditionalAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Effect} effect
   * @return {this}
   */
  effect(effect) {
    this.transformation.effect(effect);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Adjust} action
   * @return {this}
   */
  adjust(action) {
    this.transformation.adjust(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Rotate} rotate
   * @return {this}
   */
  rotate(rotate) {
    this.transformation.rotate(rotate);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    this.transformation.namedTransformation(namedTransformation);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Delivery} deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    this.transformation.delivery(deliveryAction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Qualifiers.color} color
   * @return {this}
   */
  backgroundColor(color2) {
    this.transformation.backgroundColor(color2);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.PSDTools} action
   * @return {this}
   */
  psdTools(action) {
    this.transformation.psdTools(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Extract} action
   * @return {this}
   */
  extract(action) {
    this.transformation.extract(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    this.transformation.addFlag(flagQualifier);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.CustomFunction} customFunction
   * @return {this}
   */
  customFunction(customFunction) {
    this.transformation.customFunction(customFunction);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    this.transformation.addAction(action);
    return this;
  }
  /**
   * @description Extend your transformation with another transformation
   * @param { string | SDK.Transformation } tx
   */
  addTransformation(tx) {
    this.transformation.addTransformation(tx);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {string}
   */
  toString() {
    return this.transformation.toString();
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {this}
   */
  underlay(underlayAction) {
    this.transformation.underlay(underlayAction);
    return this;
  }
  toURL(overwriteOptions = {}) {
    return this.createCloudinaryURL(this.transformation, overwriteOptions === null || overwriteOptions === void 0 ? void 0 : overwriteOptions.trackedAnalytics);
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryImage.js
var CloudinaryImage = class extends CloudinaryTransformable {
  constructor(publicID, cloudConfig, urlConfig) {
    super(publicID, cloudConfig, urlConfig, new ImageTransformation());
  }
};

// node_modules/@cloudinary/url-gen/assets/CloudinaryVideo.js
var CloudinaryVideo = class extends CloudinaryTransformable {
  constructor(publicID, cloudConfig, urlConfig) {
    super(publicID, cloudConfig, urlConfig, new VideoTransformation());
    this.assetType = "video";
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Transcode} action
   * @return {this}
   */
  transcode(action) {
    this.transformation.transcode(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.VideoEdit} action
   * @return {this}
   */
  videoEdit(action) {
    this.transformation.videoEdit(action);
    return this;
  }
};

// node_modules/@cloudinary/url-gen/internal/utils/cloneDeep.js
var LARGE_ARRAY_SIZE2 = 200;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag2 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag2 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag2 = "[object Object]";
var promiseTag2 = "[object Promise]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var weakMapTag2 = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reFlags = /\w*$/;
var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var cloneableTags2 = {};
cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
function addMapEntry(map, pair) {
  map.set(pair[0], pair[1]);
  return map;
}
function addSetEntry(set, value) {
  set.add(value);
  return set;
}
function arrayEach(array, iteratee) {
  var index = -1, length = array ? array.length : 0;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array ? array.length : 0;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject2(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!`${value}`;
    } catch (e) {
    }
  }
  return result;
}
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function overArg2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var arrayProto2 = Array.prototype;
var funcProto2 = Function.prototype;
var objectProto2 = Object.prototype;
var coreJsData2 = root2["__core-js_shared__"];
var maskSrcKey2 = function() {
  var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
  return uid ? `Symbol(src)_1.${uid}` : "";
}();
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
var objectToString2 = objectProto2.toString;
var reIsNative2 = RegExp(`^${funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?")}$`);
var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
var Symbol2 = root2.Symbol;
var Uint8Array2 = root2.Uint8Array;
var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
var objectCreate = Object.create;
var propertyIsEnumerable2 = objectProto2.propertyIsEnumerable;
var splice2 = arrayProto2.splice;
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
var nativeKeys2 = overArg2(Object.keys, Object);
var DataView2 = getNative2(root2, "DataView");
var Map2 = getNative2(root2, "Map");
var Promise3 = getNative2(root2, "Promise");
var Set2 = getNative2(root2, "Set");
var WeakMap2 = getNative2(root2, "WeakMap");
var nativeCreate2 = getNative2(Object, "create");
var dataViewCtorString2 = toSource2(DataView2);
var mapCtorString2 = toSource2(Map2);
var promiseCtorString2 = toSource2(Promise3);
var setCtorString2 = toSource2(Set2);
var weakMapCtorString2 = toSource2(WeakMap2);
var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0;
var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
function Hash2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear2() {
  this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
}
function hashDelete2(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet2(key) {
  var data = this.__data__;
  if (nativeCreate2) {
    var result = data[key];
    return result === HASH_UNDEFINED2 ? void 0 : result;
  }
  return hasOwnProperty2.call(data, key) ? data[key] : void 0;
}
function hashHas2(key) {
  var data = this.__data__;
  return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
}
function hashSet2(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
Hash2.prototype.clear = hashClear2;
Hash2.prototype.delete = hashDelete2;
Hash2.prototype.get = hashGet2;
Hash2.prototype.has = hashHas2;
Hash2.prototype.set = hashSet2;
function ListCache2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear2() {
  this.__data__ = [];
}
function listCacheDelete2(key) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice2.call(data, index, 1);
  }
  return true;
}
function listCacheGet2(key) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas2(key) {
  return assocIndexOf2(this.__data__, key) > -1;
}
function listCacheSet2(key, value) {
  var data = this.__data__, index = assocIndexOf2(data, key);
  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache2.prototype.clear = listCacheClear2;
ListCache2.prototype.delete = listCacheDelete2;
ListCache2.prototype.get = listCacheGet2;
ListCache2.prototype.has = listCacheHas2;
ListCache2.prototype.set = listCacheSet2;
function MapCache2(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear2() {
  this.__data__ = {
    "hash": new Hash2(),
    "map": new (Map2 || ListCache2)(),
    "string": new Hash2()
  };
}
function mapCacheDelete2(key) {
  return getMapData2(this, key).delete(key);
}
function mapCacheGet2(key) {
  return getMapData2(this, key).get(key);
}
function mapCacheHas2(key) {
  return getMapData2(this, key).has(key);
}
function mapCacheSet2(key, value) {
  getMapData2(this, key).set(key, value);
  return this;
}
MapCache2.prototype.clear = mapCacheClear2;
MapCache2.prototype.delete = mapCacheDelete2;
MapCache2.prototype.get = mapCacheGet2;
MapCache2.prototype.has = mapCacheHas2;
MapCache2.prototype.set = mapCacheSet2;
function Stack2(entries) {
  this.__data__ = new ListCache2(entries);
}
function stackClear2() {
  this.__data__ = new ListCache2();
}
function stackDelete2(key) {
  return this.__data__.delete(key);
}
function stackGet2(key) {
  return this.__data__.get(key);
}
function stackHas2(key) {
  return this.__data__.has(key);
}
function stackSet2(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache2) {
    var pairs = cache.__data__;
    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache2(pairs);
  }
  cache.set(key, value);
  return this;
}
Stack2.prototype.clear = stackClear2;
Stack2.prototype.delete = stackDelete2;
Stack2.prototype.get = stackGet2;
Stack2.prototype.has = stackHas2;
Stack2.prototype.set = stackSet2;
function arrayLikeKeys(value, inherited) {
  var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
  var length = result.length, skipIndexes = !!length;
  for (var key in value) {
    if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
    object[key] = value;
  }
}
function assocIndexOf2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseAssign(object, source2) {
  return object && copyObject(source2, keys(source2), object);
}
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject4(value)) {
    return value;
  }
  var isArr = isArray2(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
      if (isHostObject2(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags2[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  stack || (stack = new Stack2());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
  });
  return result;
}
function baseCreate(proto) {
  return isObject4(proto) ? objectCreate(proto) : {};
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
}
function baseGetTag2(value) {
  return objectToString2.call(value);
}
function baseIsNative2(value) {
  if (!isObject4(value) || isMasked2(value)) {
    return false;
  }
  var pattern = isFunction3(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
  return pattern.test(toSource2(value));
}
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys2(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor());
}
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor());
}
function cloneSymbol(symbol) {
  return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source2, array) {
  var index = -1, length = source2.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source2[index];
  }
  return array;
}
function copyObject(source2, props, object, customizer) {
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
  }
  return object;
}
function copySymbols(source2, object) {
  return copyObject(source2, getSymbols2(source2), object);
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols2);
}
function getMapData2(map, key) {
  var data = map.__data__;
  return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative2(object, key) {
  var value = getValue2(object, key);
  return baseIsNative2(value) ? value : void 0;
}
var getSymbols2 = nativeGetSymbols2 ? overArg2(nativeGetSymbols2, Object) : stubArray2;
var getTag2 = baseGetTag2;
if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
  getTag2 = function(value) {
    var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString2:
          return dataViewTag2;
        case mapCtorString2:
          return mapTag2;
        case promiseCtorString2:
          return promiseTag2;
        case setCtorString2:
          return setTag2;
        case weakMapCtorString2:
          return weakMapTag2;
      }
    }
    return result;
  };
}
function initCloneArray(array) {
  var length = array.length, result = array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype2(object)) : {};
}
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag2:
      return cloneDataView(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray(object, isDeep);
    case mapTag2:
      return cloneMap(object, isDeep, cloneFunc);
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp(object);
    case setTag2:
      return cloneSet(object, isDeep, cloneFunc);
    case symbolTag2:
      return cloneSymbol(object);
  }
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKeyable2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked2(func) {
  return !!maskSrcKey2 && maskSrcKey2 in func;
}
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
  return value === proto;
}
function toSource2(func) {
  if (func != null) {
    try {
      return funcToString2.call(func);
    } catch (e) {
    }
    try {
      return `${func}`;
    } catch (e) {
    }
  }
  return "";
}
function cloneDeep2(value) {
  return baseClone(value, true, true);
}
function eq2(value, other) {
  return value === other || value !== value && other !== other;
}
function isArguments(value) {
  return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString2.call(value) == argsTag2);
}
var isArray2 = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction3(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
var isBuffer = nativeIsBuffer2 || stubFalse;
function isFunction3(value) {
  var tag = isObject4(value) ? objectToString2.call(value) : "";
  return tag == funcTag2 || tag == genTag2;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject4(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function stubArray2() {
  return [];
}
function stubFalse() {
  return false;
}

// node_modules/@cloudinary/url-gen/assets/CloudinaryMedia.js
var CloudinaryMedia = class extends CloudinaryTransformable {
  constructor(publicID, cloudConfig, urlConfig) {
    super(publicID, cloudConfig, urlConfig, new Transformation());
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.Transcode} action
   * @return {this}
   */
  transcode(action) {
    this.transformation.transcode(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @param {Actions.VideoEdit} action
   * @return {this}
   */
  videoEdit(action) {
    this.transformation.videoEdit(action);
    return this;
  }
  /**
   * @desc A proxy to {@link SDK.Transformation| Transformation} - Calls the same method contained in this.transformation
   * @return {this}
   */
  underlay(underlayAction) {
    this.transformation.underlay(underlayAction);
    return this;
  }
  clone() {
    return cloneDeep2(this);
  }
};

// node_modules/@cloudinary/url-gen/instance/Cloudinary.js
var Cloudinary = class {
  constructor(cloudinaryConfig) {
    if (cloudinaryConfig) {
      this.cloudinaryConfig = cloudinaryConfig;
    }
  }
  image(publicID) {
    return new CloudinaryImage(publicID, this.cloudinaryConfig.cloud, this.cloudinaryConfig.url);
  }
  video(publicID) {
    return new CloudinaryVideo(publicID, this.cloudinaryConfig.cloud, this.cloudinaryConfig.url);
  }
  setConfig(cloudinaryConfig) {
    this.cloudinaryConfig = cloudinaryConfig;
    return this;
  }
  getConfig() {
    return this.cloudinaryConfig;
  }
  extendConfig() {
  }
};

// node_modules/@cloudinary/url-gen/backwards/utils/isObject.js
function isObject5(a) {
  return typeof a === "object" && a !== null;
}

// node_modules/@cloudinary/url-gen/internal/utils/base64Encode.js
function base64Encode2(input) {
  let encodedResult = "";
  if (typeof window !== "undefined") {
    encodedResult = btoa(encodeURI(decodeURI(input)));
  } else {
    encodedResult = global.Buffer.from(input).toString("base64");
  }
  return encodedResult.replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@cloudinary/url-gen/backwards/consts.js
var LEGACY_CONDITIONAL_OPERATORS2 = {
  "=": "eq",
  "!=": "ne",
  "<": "lt",
  ">": "gt",
  "<=": "lte",
  ">=": "gte",
  "&&": "and",
  "||": "or",
  "*": "mul",
  "/": "div",
  "+": "add",
  "-": "sub",
  "^": "pow"
};
var OLD_AKAMAI_SHARED_CDN2 = "cloudinary-a.akamaihd.net";
var AKAMAI_SHARED_CDN = "res.cloudinary.com";
var SHARED_CDN2 = AKAMAI_SHARED_CDN;
var LEGACY_PREDEFINED_VARS2 = {
  "aspect_ratio": "ar",
  "aspectRatio": "ar",
  "current_page": "cp",
  "currentPage": "cp",
  "duration": "du",
  "face_count": "fc",
  "faceCount": "fc",
  "height": "h",
  "initial_aspect_ratio": "iar",
  "initial_height": "ih",
  "initial_width": "iw",
  "initialAspectRatio": "iar",
  "initialHeight": "ih",
  "initialWidth": "iw",
  "initial_duration": "idu",
  "initialDuration": "idu",
  "page_count": "pc",
  "page_x": "px",
  "page_y": "py",
  "pageCount": "pc",
  "pageX": "px",
  "pageY": "py",
  "tags": "tags",
  "width": "w"
};
var NUMBER_PATTERN2 = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var OFFSET_ANY_PATTERN2 = `(${NUMBER_PATTERN2})([%pP])?`;
var RANGE_VALUE_RE2 = RegExp(`^${OFFSET_ANY_PATTERN2}$`);
var OFFSET_ANY_PATTERN_RE2 = RegExp(`(${OFFSET_ANY_PATTERN2})\\.\\.(${OFFSET_ANY_PATTERN2})`);
var LAYER_KEYWORD_PARAMS2 = {
  font_weight: "normal",
  font_style: "normal",
  text_decoration: "none",
  text_align: "",
  stroke: "none"
};

// node_modules/@cloudinary/url-gen/backwards/utils/smartEscape.js
function smartEscape2(string, unsafe = /([^a-zA-Z0-9_.\-\/:]+)/g) {
  return string.replace(unsafe, function(match) {
    return match.split("").map(function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    }).join("");
  });
}

// node_modules/@cloudinary/url-gen/backwards/utils/snakeCase.js
var snakeCase2 = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);

// node_modules/@cloudinary/url-gen/backwards/legacyLayer/layer.js
var Layer = class _Layer {
  /**
   * Layer
   * @constructor Layer
   * @param {Object} options - layer parameters
   */
  constructor(options) {
    this.options = {};
    if (options != null) {
      ["resourceType", "type", "publicId", "format"].forEach((key) => {
        var ref;
        return this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase2(key)];
      });
    }
  }
  resourceType(value) {
    this.options.resourceType = value;
    return this;
  }
  type(value) {
    this.options.type = value;
    return this;
  }
  publicId(value) {
    this.options.publicId = value;
    return this;
  }
  /**
   * Get the public ID, formatted for layer parameter
   * @function Layer#getPublicId
   * @return {String} public ID
   */
  getPublicId() {
    var ref;
    return (ref = this.options.publicId) != null ? ref.replace(/\//g, ":") : void 0;
  }
  /**
   * Get the public ID, with format if present
   * @function Layer#getFullPublicId
   * @return {String} public ID
   */
  getFullPublicId() {
    if (this.options.format != null) {
      return this.getPublicId() + "." + this.options.format;
    } else {
      return this.getPublicId();
    }
  }
  format(value) {
    this.options.format = value;
    return this;
  }
  /**
   * generate the string representation of the layer
   * @function Layer#toString
   */
  toString() {
    let components = [];
    if (this.options.publicId == null) {
      throw "Must supply publicId";
    }
    if (!(this.options.resourceType === "image")) {
      components.push(this.options.resourceType);
    }
    if (!(this.options.type === "upload")) {
      components.push(this.options.type);
    }
    components.push(this.getFullPublicId());
    return components.filter((x) => !!x).join(":");
  }
  clone() {
    return new _Layer(this.options);
  }
};
var layer_default2 = Layer;

// node_modules/@cloudinary/url-gen/backwards/utils/isEmpty.js
function isEmpty2(value) {
  return value === void 0 || value === null || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0;
}

// node_modules/@cloudinary/url-gen/backwards/utils/isNumberLike.js
var isNumberLike2 = function(value) {
  return value != null && !isNaN(parseFloat(value));
};

// node_modules/@cloudinary/url-gen/backwards/legacyLayer/textlayer.js
var TextLayer = class extends layer_default2 {
  /**
   * @constructor TextLayer
   * @param {Object} options - layer parameters
   */
  constructor(options) {
    let keys2;
    super(options);
    keys2 = ["resourceType", "resourceType", "fontFamily", "fontSize", "fontWeight", "fontStyle", "textDecoration", "textAlign", "stroke", "letterSpacing", "lineSpacing", "fontHinting", "fontAntialiasing", "text"];
    if (options != null) {
      keys2.forEach((key) => {
        var ref;
        return this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase2(key)];
      });
    }
    this.options.resourceType = "text";
  }
  //@ts-ignore
  resourceType(resourceType) {
    throw "Cannot modify resourceType for text layers";
  }
  //@ts-ignore
  type(type) {
    throw "Cannot modify type for text layers";
  }
  format(format2) {
    throw "Cannot modify format for text layers";
  }
  fontFamily(fontFamily) {
    this.options.fontFamily = fontFamily;
    return this;
  }
  fontSize(fontSize) {
    this.options.fontSize = fontSize;
    return this;
  }
  fontWeight(fontWeight) {
    this.options.fontWeight = fontWeight;
    return this;
  }
  fontStyle(fontStyle) {
    this.options.fontStyle = fontStyle;
    return this;
  }
  textDecoration(textDecoration) {
    this.options.textDecoration = textDecoration;
    return this;
  }
  textAlign(textAlign) {
    this.options.textAlign = textAlign;
    return this;
  }
  stroke(stroke) {
    this.options.stroke = stroke;
    return this;
  }
  letterSpacing(letterSpacing) {
    this.options.letterSpacing = letterSpacing;
    return this;
  }
  lineSpacing(lineSpacing) {
    this.options.lineSpacing = lineSpacing;
    return this;
  }
  fontHinting(fontHinting) {
    this.options.fontHinting = fontHinting;
    return this;
  }
  fontAntialiasing(fontAntialiasing) {
    this.options.fontAntialiasing = fontAntialiasing;
    return this;
  }
  text(text) {
    this.options.text = text;
    return this;
  }
  /**
   * generate the string representation of the layer
   * @function TextLayer#toString
   * @return {String}
   */
  toString() {
    var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;
    style = this.textStyleIdentifier();
    if (this.options.publicId != null) {
      publicId = this.getFullPublicId();
    }
    if (this.options.text != null) {
      hasPublicId = !isEmpty2(publicId);
      hasStyle = !isEmpty2(style);
      if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {
        throw "Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!";
      }
      re = /\$\([a-zA-Z]\w*\)/g;
      start = 0;
      textSource = smartEscape2(this.options.text, /[,\/]/g);
      text = "";
      while (res = re.exec(textSource)) {
        text += smartEscape2(textSource.slice(start, res.index));
        text += res[0];
        start = res.index + res[0].length;
      }
      text += smartEscape2(textSource.slice(start));
    }
    components = [this.options.resourceType, style, publicId, text];
    return components.filter((x) => !!x).join(":");
  }
  textStyleIdentifier() {
    var components;
    components = [];
    if (this.options.fontWeight !== "normal") {
      components.push(this.options.fontWeight);
    }
    if (this.options.fontStyle !== "normal") {
      components.push(this.options.fontStyle);
    }
    if (this.options.textDecoration !== "none") {
      components.push(this.options.textDecoration);
    }
    components.push(this.options.textAlign);
    if (this.options.stroke !== "none") {
      components.push(this.options.stroke);
    }
    if (!(isEmpty2(this.options.letterSpacing) && !isNumberLike2(this.options.letterSpacing))) {
      components.push("letter_spacing_" + this.options.letterSpacing);
    }
    if (!(isEmpty2(this.options.lineSpacing) && !isNumberLike2(this.options.lineSpacing))) {
      components.push("line_spacing_" + this.options.lineSpacing);
    }
    if (!isEmpty2(this.options.fontAntialiasing)) {
      components.push("antialias_" + this.options.fontAntialiasing);
    }
    if (!isEmpty2(this.options.fontHinting)) {
      components.push("hinting_" + this.options.fontHinting);
    }
    if (!isEmpty2(components.filter((x) => !!x))) {
      if (isEmpty2(this.options.fontFamily)) {
        throw `Must supply fontFamily. ${components}`;
      }
      if (isEmpty2(this.options.fontSize) && !isNumberLike2(this.options.fontSize)) {
        throw "Must supply fontSize.";
      }
    }
    components.unshift(this.options.fontFamily, this.options.fontSize);
    components = components.filter((x) => !!x).join("_");
    return components;
  }
};
var textlayer_default2 = TextLayer;

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processLayer.js
function textStyle(layer) {
  const keywords = [];
  let style = "";
  Object.keys(LAYER_KEYWORD_PARAMS2).forEach((attr) => {
    let default_value = LAYER_KEYWORD_PARAMS2[attr];
    let attr_value = layer[attr] || default_value;
    if (attr_value !== default_value) {
      keywords.push(attr_value);
    }
  });
  Object.keys(layer).forEach((attr) => {
    if (attr === "letter_spacing" || attr === "line_spacing") {
      keywords.push(`${attr}_${layer[attr]}`);
    }
    if (attr === "font_hinting") {
      keywords.push(`${attr.split("_").pop()}_${layer[attr]}`);
    }
    if (attr === "font_antialiasing") {
      keywords.push(`antialias_${layer[attr]}`);
    }
  });
  if (layer.hasOwnProperty("font_size") || !keywords || keywords.length === 0) {
    if (!layer.font_size)
      throw `Must supply font_size for text in overlay/underlay`;
    if (!layer.font_family)
      throw `Must supply font_family for text in overlay/underlay`;
    keywords.unshift(layer.font_size);
    keywords.unshift(layer.font_family);
    style = keywords.filter((a) => a).join("_");
  }
  return style;
}
function processLayer2(layer) {
  if (layer instanceof textlayer_default2 || layer instanceof layer_default2) {
    return layer.toString();
  }
  let result = "";
  if (isObject5(layer)) {
    if (layer.resource_type === "fetch" || layer.url != null) {
      result = `fetch:${base64Encode2(layer.url)}`;
    } else {
      let public_id = layer.public_id;
      let format2 = layer.format;
      let resource_type = layer.resource_type || "image";
      let type = layer.type || "upload";
      let text = layer.text;
      let style = null;
      let components = [];
      const noPublicId = !public_id || public_id.length === 0;
      if (!noPublicId) {
        public_id = public_id.replace(new RegExp("/", "g"), ":");
        if (format2 != null) {
          public_id = `${public_id}.${format2}`;
        }
      }
      if ((!text || text.length === 0) && resource_type !== "text") {
        if (noPublicId) {
          throw "Must supply public_id for resource_type layer_parameter";
        }
        if (resource_type === "subtitles") {
          style = textStyle(layer);
        }
      } else {
        resource_type = "text";
        type = null;
        style = textStyle(layer);
        if (text && text.length >= 0) {
          const noStyle = !style;
          if (!(noPublicId || noStyle) || noPublicId && noStyle) {
            throw "Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay";
          }
          let re = /\$\([a-zA-Z]\w*\)/g;
          let start = 0;
          let textSource = smartEscape2(decodeURIComponent(text), /[,\/]/g);
          text = "";
          for (let res = re.exec(textSource); res; res = re.exec(textSource)) {
            text += smartEscape2(textSource.slice(start, res.index));
            text += res[0];
            start = res.index + res[0].length;
          }
          text += encodeURIComponent(textSource.slice(start));
        }
      }
      if (resource_type !== "image") {
        components.push(resource_type);
      }
      if (type !== "upload") {
        components.push(type);
      }
      components.push(style);
      components.push(public_id);
      components.push(text);
      result = components.filter((a) => a).join(":");
    }
  } else if (/^fetch:.+/.test(layer)) {
    result = `fetch:${base64Encode2(layer.substr(6))}`;
  } else {
    result = layer;
  }
  return result;
}

// node_modules/@cloudinary/url-gen/backwards/utils/legacyNormalizeExpression.js
function legacyNormalizeExpression2(expression) {
  if (typeof expression !== "string" || expression.length === 0 || expression.match(/^!.+!$/)) {
    if (expression) {
      return expression.toString();
    } else {
      return expression;
    }
  }
  expression = String(expression);
  const operators = "\\|\\||>=|<=|&&|!=|>|=|<|/|-|\\+|\\*|\\^";
  const operatorsPattern = "((" + operators + ")(?=[ _]))";
  const operatorsReplaceRE = new RegExp(operatorsPattern, "g");
  expression = expression.replace(operatorsReplaceRE, (match) => {
    return LEGACY_CONDITIONAL_OPERATORS2[match];
  });
  const predefinedVarsPattern = "(" + Object.keys(LEGACY_PREDEFINED_VARS2).join("|") + ")";
  const userVariablePattern = "(\\$_*[^_ ]+)";
  const variablesReplaceRE = new RegExp(`${userVariablePattern}|${predefinedVarsPattern}`, "g");
  expression = expression.replace(variablesReplaceRE, (match) => LEGACY_PREDEFINED_VARS2[match] || match);
  return expression.replace(/[ _]+/g, "_");
}

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processIf.js
function process_if2(ifValue) {
  return ifValue ? "if_" + legacyNormalizeExpression2(ifValue) : ifValue;
}

// node_modules/@cloudinary/url-gen/backwards/utils/toArray.js
function toArray2(arg) {
  switch (true) {
    case arg == null:
      return [];
    case Array.isArray(arg):
      return arg;
    default:
      return [arg];
  }
}

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processRadius.js
function processRadius2(_radius) {
  let radius = _radius;
  if (!radius) {
    return radius;
  }
  if (!Array.isArray(radius)) {
    radius = [radius];
  }
  if (radius.length === 0 || radius.length > 4) {
    throw new Error("Radius array should contain between 1 and 4 values");
  }
  if (radius.findIndex((x) => x === null) >= 0) {
    throw new Error("Corner: Cannot be null");
  }
  return radius.map(legacyNormalizeExpression2).join(":");
}

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processCustomFunction.js
function processCustomFunction2(customFunction) {
  if (!isObject5(customFunction)) {
    return customFunction;
  }
  if (customFunction.function_type === "remote") {
    const encodedSource = base64Encode2(customFunction.source).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    return [customFunction.function_type, encodedSource].join(":");
  }
  return [customFunction.function_type, customFunction.source].join(":");
}

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processCustomPreFunction.js
function processCustomPreFunction2(customPreFunction) {
  const result = processCustomFunction2(customPreFunction);
  return typeof result === "string" ? `pre:${result}` : null;
}

// node_modules/@cloudinary/url-gen/backwards/utils/splitRange.js
function splitRange2(range) {
  switch (range && range.constructor) {
    case String:
      if (!OFFSET_ANY_PATTERN_RE2.test(range)) {
        return range;
      }
      return range.split("..");
    case Array:
      return [[range], range[range.length - 1]];
    default:
      return [null, null];
  }
}

// node_modules/@cloudinary/url-gen/backwards/utils/norm_range_values.js
function normRangeValues2(value) {
  const offset = String(value).match(RANGE_VALUE_RE2);
  if (offset) {
    const modifier = offset[5] ? "p" : "";
    return `${offset[1] || offset[4]}${modifier}`;
  } else {
    return value;
  }
}

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processVideoParams.js
function processVideoParams2(param) {
  switch (param && param.constructor) {
    case Object: {
      let video = "";
      if ("codec" in param) {
        video = param.codec;
        if ("profile" in param) {
          video += ":" + param.profile;
          if ("level" in param) {
            video += ":" + param.level;
          }
        }
      }
      return video;
    }
    case String:
      return param;
    default:
      return null;
  }
}

// node_modules/@cloudinary/url-gen/backwards/expression.js
var Expression2 = class _Expression {
  constructor(expressionStr) {
    this.expressions = [];
    if (expressionStr != null) {
      this.expressions.push(_Expression.normalize(expressionStr));
    }
  }
  /**
   * Convenience constructor method
   * @function Expression.new
   */
  static new(expressionStr) {
    return new this(expressionStr);
  }
  /**
   * Normalize a string expression
   * @function Cloudinary#normalize
   * @param {string} expression a expression, e.g. "w gt 100", "width_gt_100", "width > 100"
   * @return {string} the normalized form of the value expression, e.g. "w_gt_100"
   */
  static normalize(expression) {
    var operators, operatorsPattern, operatorsReplaceRE, predefinedVarsPattern, predefinedVarsReplaceRE;
    if (expression == null) {
      return expression;
    }
    expression = String(expression);
    operators = "\\|\\||>=|<=|&&|!=|>|=|<|/|-|\\+|\\*|\\^";
    operatorsPattern = "((" + operators + ")(?=[ _]))";
    operatorsReplaceRE = new RegExp(operatorsPattern, "g");
    expression = expression.replace(operatorsReplaceRE, (match) => OPERATORS[match]);
    predefinedVarsPattern = "(" + Object.keys(PREDEFINED_VARS).join("|") + ")";
    predefinedVarsReplaceRE = new RegExp(predefinedVarsPattern, "g");
    expression = expression.replace(predefinedVarsReplaceRE, (match, p1, offset) => expression[offset - 1] === "$" ? match : PREDEFINED_VARS[match]);
    return expression.replace(/[ _]+/g, "_");
  }
  /**
   * Serialize the expression
   * @return {string} the expression as a string
   */
  serialize() {
    return _Expression.normalize(this.expressions.join("_"));
  }
  toString() {
    return this.serialize();
  }
  /**
   * Get the parent transformation of this expression
   * @return Transformation
   */
  getParent() {
    return this.parent;
  }
  /**
   * Set the parent transformation of this expression
   * @param {Transformation} the parent transformation
   * @return {Expression} this expression
   */
  setParent(parent) {
    this.parent = parent;
    return this;
  }
  /**
   * Add a expression
   * @function Expression#predicate
   * @internal
   */
  predicate(name2, operator, value) {
    if (OPERATORS[operator] != null) {
      operator = OPERATORS[operator];
    }
    this.expressions.push(`${name2}_${operator}_${value}`);
    return this;
  }
  /**
   * @function Expression#and
   */
  and() {
    this.expressions.push("and");
    return this;
  }
  /**
   * @function Expression#or
   */
  or() {
    this.expressions.push("or");
    return this;
  }
  /**
   * Conclude expression
   * @function Expression#then
   * @return {Transformation} the transformation this expression is defined for
   */
  then() {
    return this.getParent().if(this.toString());
  }
  /**
   * @function Expression#height
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Expression} this expression
   */
  height(operator, value) {
    return this.predicate("h", operator, value);
  }
  /**
   * @function Expression#width
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Expression} this expression
   */
  width(operator, value) {
    return this.predicate("w", operator, value);
  }
  /**
   * @function Expression#aspectRatio
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Expression} this expression
   */
  aspectRatio(operator, value) {
    return this.predicate("ar", operator, value);
  }
  /**
   * @function Expression#pages
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Expression} this expression
   */
  pageCount(operator, value) {
    return this.predicate("pc", operator, value);
  }
  /**
   * @function Expression#faces
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Expression} this expression
   */
  faceCount(operator, value) {
    return this.predicate("fc", operator, value);
  }
  value(value) {
    this.expressions.push(value);
    return this;
  }
  /**
   */
  static variable(name2, value) {
    return new this(name2).value(value);
  }
  /**
   * @returns Expression a new expression with the predefined variable "width"
   * @function Expression.width
   */
  static width() {
    return new this("width");
  }
  /**
   * @returns Expression a new expression with the predefined variable "height"
   * @function Expression.height
   */
  static height() {
    return new this("height");
  }
  /**
   * @returns Expression a new expression with the predefined variable "initialWidth"
   * @function Expression.initialWidth
   */
  static initialWidth() {
    return new this("initialWidth");
  }
  /**
   * @returns Expression a new expression with the predefined variable "initialHeight"
   * @function Expression.initialHeight
   */
  static initialHeight() {
    return new this("initialHeight");
  }
  /**
   * @returns Expression a new expression with the predefined variable "aspectRatio"
   * @function Expression.aspectRatio
   */
  static aspectRatio() {
    return new this("aspectRatio");
  }
  /**
   * @returns Expression a new expression with the predefined variable "initialAspectRatio"
   * @function Expression.initialAspectRatio
   */
  static initialAspectRatio() {
    return new this("initialAspectRatio");
  }
  /**
   * @returns Expression a new expression with the predefined variable "pageCount"
   * @function Expression.pageCount
   */
  static pageCount() {
    return new this("pageCount");
  }
  /**
   * @returns Expression new expression with the predefined variable "faceCount"
   * @function Expression.faceCount
   */
  static faceCount() {
    return new this("faceCount");
  }
  /**
   * @returns Expression a new expression with the predefined variable "currentPage"
   * @function Expression.currentPage
   */
  static currentPage() {
    return new this("currentPage");
  }
  /**
   * @returns Expression a new expression with the predefined variable "tags"
   * @function Expression.tags
   */
  static tags() {
    return new this("tags");
  }
  /**
   * @returns Expression a new expression with the predefined variable "pageX"
   * @function Expression.pageX
   */
  static pageX() {
    return new this("pageX");
  }
  /**
   * @returns Expression a new expression with the predefined variable "pageY"
   * @function Expression.pageY
   */
  static pageY() {
    return new this("pageY");
  }
};
var OPERATORS = {
  "=": "eq",
  "!=": "ne",
  "<": "lt",
  ">": "gt",
  "<=": "lte",
  ">=": "gte",
  "&&": "and",
  "||": "or",
  "*": "mul",
  "/": "div",
  "+": "add",
  "-": "sub",
  "^": "pow"
};
var PREDEFINED_VARS = {
  "aspect_ratio": "ar",
  "aspectRatio": "ar",
  "current_page": "cp",
  "currentPage": "cp",
  "preview:duration": "preview:duration",
  "duration": "du",
  "face_count": "fc",
  "faceCount": "fc",
  "height": "h",
  "initial_aspect_ratio": "iar",
  "initial_duration": "idu",
  "initial_height": "ih",
  "initial_width": "iw",
  "initialAspectRatio": "iar",
  "initialDuration": "idu",
  "initialHeight": "ih",
  "initialWidth": "iw",
  "page_count": "pc",
  "page_x": "px",
  "page_y": "py",
  "pageCount": "pc",
  "pageX": "px",
  "pageY": "py",
  "tags": "tags",
  "width": "w"
};
var expression_default2 = Expression2;

// node_modules/@cloudinary/url-gen/backwards/condition.js
var Condition = class extends expression_default2 {
  constructor(conditionStr) {
    super(conditionStr);
  }
  /**
   * @function Condition#height
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  height(operator, value) {
    return this.predicate("h", operator, value);
  }
  /**
   * @function Condition#width
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  width(operator, value) {
    return this.predicate("w", operator, value);
  }
  /**
   * @function Condition#aspectRatio
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  aspectRatio(operator, value) {
    return this.predicate("ar", operator, value);
  }
  /**
   * @function Condition#pages
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  pageCount(operator, value) {
    return this.predicate("pc", operator, value);
  }
  /**
   * @function Condition#faces
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  faceCount(operator, value) {
    return this.predicate("fc", operator, value);
  }
  /**
   * @function Condition#duration
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  duration(operator, value) {
    return this.predicate("du", operator, value);
  }
  /**
   * @function Condition#initialDuration
   * @param {string} operator the comparison operator (e.g. "<", "lt")
   * @param {string|number} value the right hand side value
   * @return {Condition} this condition
   */
  initialDuration(operator, value) {
    return this.predicate("idu", operator, value);
  }
};
var condition_default2 = Condition;

// node_modules/@cloudinary/url-gen/backwards/configuration.js
var DEFAULT_CONFIGURATION_PARAMS2 = {
  responsive_class: "cld-responsive",
  responsive_use_breakpoints: true,
  round_dpr: true,
  secure: (typeof window !== "undefined" && window !== null ? window.location ? window.location.protocol : void 0 : void 0) === "https:"
};
var CONFIG_PARAMS2 = [
  "api_key",
  "api_secret",
  "callback",
  "cdn_subdomain",
  "cloud_name",
  "cname",
  "private_cdn",
  "protocol",
  "resource_type",
  "responsive",
  "responsive_class",
  "responsive_use_breakpoints",
  "responsive_width",
  "round_dpr",
  "secure",
  "secure_cdn_subdomain",
  "secure_distribution",
  "shorten",
  "type",
  "upload_preset",
  "url_suffix",
  "use_root_path",
  "version",
  "externalLibraries",
  "max_timeout_ms"
];

// node_modules/@cloudinary/url-gen/backwards/utils/legacyBaseUtil.js
var withCamelCaseKeys2 = function(source2) {
  return convertKeys(source2, camelCase2);
};
var camelCase2 = function(source2) {
  let words = source2.match(reWords2);
  words = words.map((word) => word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase());
  words[0] = words[0].toLocaleLowerCase();
  return words.join("");
};
var convertKeys = function(source2, converter) {
  var result, value;
  result = {};
  for (let key in source2) {
    value = source2[key];
    if (converter) {
      key = converter(key);
    }
    if (!isEmpty2(key)) {
      result[key] = value;
    }
  }
  return result;
};
var reWords2 = function() {
  var lower, upper;
  upper = "[A-Z]";
  lower = "[a-z]+";
  return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
}();
function identity2(x) {
  return x;
}
function contains2(a, obj) {
  for (let i = 0; i < a.length; i++) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
}
function difference2(arr1, arr2) {
  return arr1.filter((x) => !arr2.includes(x));
}

// node_modules/@cloudinary/url-gen/backwards/legacyLayer/subtitleslayer.js
var SubtitlesLayer = class extends textlayer_default2 {
  /**
   * Represent a subtitles layer
   * @constructor SubtitlesLayer
   * @param {Object} options - layer parameters
   */
  constructor(options) {
    super(options);
    this.options.resourceType = "subtitles";
  }
};
var subtitleslayer_default2 = SubtitlesLayer;

// node_modules/@cloudinary/url-gen/internal/utils/dataStructureUtils.js
function isString2(value) {
  return typeof value === "string" || value instanceof String;
}

// node_modules/@cloudinary/url-gen/backwards/legacyLayer/fetchlayer.js
var FetchLayer = class extends layer_default2 {
  /**
   * @class FetchLayer
   * @classdesc Creates an image layer using a remote URL.
   * @param {Object|string} options - layer parameters or a url
   * @param {string} options.url the url of the image to fetch
   */
  constructor(options) {
    super(options);
    if (isString2(options)) {
      this.options.url = options;
    } else if (options != null ? options.url : void 0) {
      this.options.url = options.url;
    }
  }
  url(url) {
    this.options.url = url;
    return this;
  }
  /**
   * generate the string representation of the layer
   * @function FetchLayer#toString
   * @return {String}
   */
  toString() {
    return `fetch:${base64Encode2(this.options.url)}`;
  }
};
var fetchlayer_default2 = FetchLayer;

// node_modules/@cloudinary/url-gen/backwards/utils/isFunction.js
function isFunction4(variableToCheck) {
  return variableToCheck instanceof Function;
}

// node_modules/@cloudinary/url-gen/backwards/transformation.js
var URL_KEYS = [
  "accessibility",
  "api_secret",
  "auth_token",
  "cdn_subdomain",
  "cloud_name",
  "cname",
  "format",
  "placeholder",
  "private_cdn",
  "resource_type",
  "secure",
  "secure_cdn_subdomain",
  "secure_distribution",
  "shorten",
  "sign_url",
  "signature",
  "ssl_detected",
  "type",
  "url_suffix",
  "use_root_path",
  "version"
];
function assignNotNull(target, ...sources) {
  sources.forEach((source2) => {
    Object.keys(source2).forEach((key) => {
      if (source2[key] != null) {
        target[key] = source2[key];
      }
    });
  });
  return target;
}
var allStrings = function(list) {
  return list.length && list.every(isString2);
};
var Param = class {
  /**
   * Represents a single parameter.
   * @class Param
   * @param {string} name - The name of the parameter in snake_case
   * @param {string} shortName - The name of the serialized form of the parameter.
   *                         If a value is not provided, the parameter will not be serialized.
   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called
   * @ignore
   */
  constructor(name2, shortName, process2 = identity2) {
    this.name = name2;
    this.shortName = shortName;
    this.process = process2;
  }
  /**
   * Set a (unprocessed) value for this parameter
   * @function Param#set
   * @param {*} origValue - the value of the parameter
   * @return {Param} self for chaining
   */
  set(origValue) {
    this.origValue = origValue;
    return this;
  }
  /**
   * Generate the serialized form of the parameter
   * @function Param#serialize
   * @return {string} the serialized form of the parameter
   */
  serialize() {
    var val, valid;
    val = this.value();
    valid = Array.isArray(val) || isObject5(val) || isString2(val) ? !isEmpty2(val) : val != null;
    if (this.shortName != null && valid) {
      return `${this.shortName}_${val}`;
    } else {
      return "";
    }
  }
  /**
   * Return the processed value of the parameter
   * @function Param#value
   */
  value() {
    return this.process(this.origValue);
  }
  static norm_color(value) {
    return value != null ? value.replace(/^#/, "rgb:") : void 0;
  }
  static build_array(arg) {
    if (arg == null) {
      return [];
    } else if (Array.isArray(arg)) {
      return arg;
    } else {
      return [arg];
    }
  }
  /**
   * Covert value to video codec string.
   *
   * If the parameter is an object,
   * @param {(string|Object)} param - the video codec as either a String or a Hash
   * @return {string} the video codec string in the format codec:profile:level
   * @example
   * vc_[ :profile : [level]]
   * or
   { codec: 'h264', profile: 'basic', level: '3.1' }
   * @ignore
   */
  static process_video_params(param) {
    var video;
    switch (param.constructor) {
      case Object:
        video = "";
        if ("codec" in param) {
          video = param.codec;
          if ("profile" in param) {
            video += ":" + param.profile;
            if ("level" in param) {
              video += ":" + param.level;
            }
          }
        }
        return video;
      case String:
        return param;
      default:
        return null;
    }
  }
};
var ArrayParam = class extends Param {
  /**
   * A parameter that represents an array.
   * @param {string} name - The name of the parameter in snake_case.
   * @param {string} shortName - The name of the serialized form of the parameter
   *                         If a value is not provided, the parameter will not be serialized.
   * @param {string} [sep='.'] - The separator to use when joining the array elements together
   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called
   * @class ArrayParam
   * @extends Param
   * @ignore
   */
  constructor(name2, shortName, sep = ".", process2 = void 0) {
    super(name2, shortName, process2);
    this.sep = sep;
  }
  serialize() {
    if (this.shortName != null) {
      let arrayValue = this.value();
      if (isEmpty2(arrayValue)) {
        return "";
      } else if (isString2(arrayValue)) {
        return `${this.shortName}_${arrayValue}`;
      } else {
        let flat = arrayValue.map((t) => isFunction4(t.serialize) ? t.serialize() : t).join(this.sep);
        return `${this.shortName}_${flat}`;
      }
    } else {
      return "";
    }
  }
  value() {
    if (Array.isArray(this.origValue)) {
      return this.origValue.map((v) => this.process(v));
    } else {
      return this.process(this.origValue);
    }
  }
  set(origValue) {
    if (origValue == null || Array.isArray(origValue)) {
      return super.set(origValue);
    } else {
      return super.set([origValue]);
    }
  }
};
var TransformationParam = class extends Param {
  /**
   * A parameter that represents a transformation
   * @param {string} name - The name of the parameter in snake_case
   * @param {string} [shortName='t'] - The name of the serialized form of the parameter
   * @param {string} [sep='.'] - The separator to use when joining the array elements together
   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called
   * @class TransformationParam
   * @extends Param
   * @ignore
   */
  constructor(name2, shortName = "t", sep = ".", process2 = void 0) {
    super(name2, shortName, process2);
    this.sep = sep;
  }
  /**
   * Generate string representations of the transformation.
   * @returns {*} Returns either the transformation as a string, or an array of string representations.
   */
  serialize() {
    let result = "";
    const val = this.value();
    if (isEmpty2(val)) {
      return result;
    }
    if (allStrings(val)) {
      const joined = val.join(this.sep);
      if (!isEmpty2(joined)) {
        result = `${this.shortName}_${joined}`;
      }
    } else {
      result = val.map((t) => {
        if (isString2(t) && !isEmpty2(t)) {
          return `${this.shortName}_${t}`;
        }
        if (isFunction4(t.serialize)) {
          return t.serialize();
        }
        if (isObject5(t) && !isEmpty2(t)) {
          return new Transformation2(t).serialize();
        }
        return void 0;
      }).filter((t) => t);
    }
    return result;
  }
  set(origValue1) {
    this.origValue = origValue1;
    if (Array.isArray(this.origValue)) {
      return super.set(this.origValue);
    } else {
      return super.set([this.origValue]);
    }
  }
};
var number_pattern2 = "([0-9]*)\\.([0-9]+)|([0-9]+)";
var offset_any_pattern2 = "(" + number_pattern2 + ")([%pP])?";
var RangeParam = class _RangeParam extends Param {
  /**
   * A parameter that represents a range
   * @param {string} name - The name of the parameter in snake_case
   * @param {string} shortName - The name of the serialized form of the parameter
   *                         If a value is not provided, the parameter will not be serialized.
   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called
   * @class RangeParam
   * @extends Param
   * @ignore
   */
  constructor(name2, shortName, process2 = _RangeParam.norm_range_value) {
    super(name2, shortName, process2);
  }
  static norm_range_value(value) {
    let offset = String(value).match(new RegExp("^" + offset_any_pattern2 + "$"));
    if (offset) {
      let modifier = offset[5] != null ? "p" : "";
      value = (offset[1] || offset[4]) + modifier;
    }
    return value;
  }
};
var RawParam = class extends Param {
  constructor(name2, shortName, process2 = identity2) {
    super(name2, shortName, process2);
  }
  serialize() {
    return this.value();
  }
};
var LayerParam = class extends Param {
  // Parse layer options
  // @return [string] layer transformation string
  // @private
  value() {
    if (this.origValue == null) {
      return "";
    }
    let result;
    if (this.origValue instanceof layer_default2) {
      result = this.origValue;
    } else if (isObject5(this.origValue)) {
      let layerOptions = withCamelCaseKeys2(this.origValue);
      if (layerOptions.resourceType === "text" || layerOptions.text != null) {
        result = new textlayer_default2(layerOptions);
      } else {
        if (layerOptions.resourceType === "subtitles") {
          result = new subtitleslayer_default2(layerOptions);
        } else {
          if (layerOptions.resourceType === "fetch" || layerOptions.url != null) {
            result = new fetchlayer_default2(layerOptions);
          } else {
            result = new layer_default2(layerOptions);
          }
        }
      }
    } else if (isString2(this.origValue)) {
      if (/^fetch:.+/.test(this.origValue)) {
        result = new fetchlayer_default2(this.origValue.substr(6));
      } else {
        result = this.origValue;
      }
    } else {
      result = "";
    }
    return result.toString();
  }
  static textStyle(layer) {
    return new textlayer_default2(layer).textStyleIdentifier();
  }
};
var TransformationBase = class _TransformationBase {
  /**
   * The base class for transformations.
   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.
   * @class TransformationBase
   */
  constructor(options) {
    let parent;
    let trans;
    parent = void 0;
    trans = {};
    this.toOptions = (withChain) => {
      let opt = {};
      if (withChain == null) {
        withChain = true;
      }
      Object.keys(trans).forEach((key) => opt[key] = trans[key].origValue);
      assignNotNull(opt, this.otherOptions);
      if (withChain && !isEmpty2(this.chained)) {
        let list = this.chained.map((tr) => tr.toOptions());
        list.push(opt);
        opt = {};
        assignNotNull(opt, this.otherOptions);
        opt.transformation = list;
      }
      return opt;
    };
    this.setParent = (object) => {
      parent = object;
      if (object != null) {
        this.fromOptions(typeof object.toOptions === "function" ? object.toOptions() : void 0);
      }
      return this;
    };
    this.getParent = () => {
      return parent;
    };
    this.param = (value, name2, abbr, defaultValue, process2) => {
      if (process2 == null) {
        if (isFunction4(defaultValue)) {
          process2 = defaultValue;
        } else {
          process2 = identity2;
        }
      }
      trans[name2] = new Param(name2, abbr, process2).set(value);
      return this;
    };
    this.rawParam = function(value, name2, abbr, defaultValue, process2) {
      process2 = lastArgCallback(arguments);
      trans[name2] = new RawParam(name2, abbr, process2).set(value);
      return this;
    };
    this.rangeParam = function(value, name2, abbr, defaultValue, process2) {
      process2 = lastArgCallback(arguments);
      trans[name2] = new RangeParam(name2, abbr, process2).set(value);
      return this;
    };
    this.arrayParam = function(value, name2, abbr, sep = ":", defaultValue = [], process2 = void 0) {
      process2 = lastArgCallback(arguments);
      trans[name2] = new ArrayParam(name2, abbr, sep, process2).set(value);
      return this;
    };
    this.transformationParam = function(value, name2, abbr, sep = ".", defaultValue = void 0, process2 = void 0) {
      process2 = lastArgCallback(arguments);
      trans[name2] = new TransformationParam(name2, abbr, sep, process2).set(value);
      return this;
    };
    this.layerParam = function(value, name2, abbr) {
      trans[name2] = new LayerParam(name2, abbr).set(value);
      return this;
    };
    this.getValue = function(name2) {
      let value = trans[name2] && trans[name2].value();
      return value != null ? value : this.otherOptions[name2];
    };
    this.get = function(name2) {
      return trans[name2];
    };
    this.remove = function(name2) {
      var temp;
      switch (false) {
        case trans[name2] == null:
          temp = trans[name2];
          delete trans[name2];
          return temp.origValue;
        case this.otherOptions[name2] == null:
          temp = this.otherOptions[name2];
          delete this.otherOptions[name2];
          return temp;
        default:
          return null;
      }
    };
    this.keys = function() {
      var key;
      return function() {
        var results;
        results = [];
        for (key in trans) {
          if (key != null) {
            results.push(key.match(VAR_NAME_RE) ? key : snakeCase2(key));
          }
        }
        return results;
      }().sort();
    };
    this.toPlainObject = function() {
      var hash, key, list;
      hash = {};
      for (key in trans) {
        hash[key] = trans[key].value();
        if (isObject5(hash[key])) {
          hash[key] = cloneDeep2(hash[key]);
        }
      }
      if (!isEmpty2(this.chained)) {
        list = this.chained.map((tr) => tr.toPlainObject());
        list.push(hash);
        hash = {
          transformation: list
        };
      }
      return hash;
    };
    this.chain = function() {
      var names, tr;
      names = Object.getOwnPropertyNames(trans);
      if (names.length !== 0) {
        tr = new this.constructor(this.toOptions(false));
        this.resetTransformations();
        this.chained.push(tr);
      }
      return this;
    };
    this.resetTransformations = function() {
      trans = {};
      return this;
    };
    this.otherOptions = {};
    this.chained = [];
    this.fromOptions(options);
  }
  /**
   * Merge the provided options with own's options
   * @param {Object} [options={}] key-value list of options
   * @returns {Transformation} Returns this instance for chaining
   */
  fromOptions(options = {}) {
    if (options instanceof _TransformationBase) {
      this.fromTransformation(options);
    } else {
      if (isString2(options) || Array.isArray(options)) {
        options = {
          transformation: options
        };
      }
      options = cloneDeep2(options);
      if (options["if"]) {
        this.set("if", options["if"]);
        delete options["if"];
      }
      for (let key in options) {
        let opt = options[key];
        if (opt != null) {
          if (key.match(VAR_NAME_RE)) {
            if (key !== "$attr") {
              this.set("variable", key, opt);
            }
          } else {
            this.set(key, opt);
          }
        }
      }
    }
    return this;
  }
  fromTransformation(other) {
    if (other instanceof _TransformationBase) {
      other.keys().forEach((key) => this.set(key, other.get(key).origValue));
    }
    return this;
  }
  /**
   * Set a parameter.
   * The parameter name `key` is converted to
   * @param {string} key - the name of the parameter
   * @param {*} values - the value of the parameter
   * @returns {Transformation} Returns this instance for chaining
   */
  set(key, ...values) {
    let camelKey;
    camelKey = camelCase2(key);
    if (contains2(methods2, camelKey)) {
      this[camelKey].apply(this, values);
    } else {
      this.otherOptions[key] = values[0];
    }
    return this;
  }
  hasLayer() {
    return this.getValue("overlay") || this.getValue("underlay");
  }
  /**
   * Generate a string representation of the transformation.
   * @function Transformation#serialize
   * @return {string} Returns the transformation as a string
   */
  serialize() {
    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;
    resultArray = this.chained.map((tr) => tr.serialize());
    paramList = this.keys();
    transformations = (ref = this.get("transformation")) != null ? ref.serialize() : void 0;
    ifParam = (ref1 = this.get("if")) != null ? ref1.serialize() : void 0;
    variables = processVar((ref2 = this.get("variables")) != null ? ref2.value() : void 0);
    paramList = difference2(paramList, ["transformation", "if", "variables"]);
    vars = [];
    transformationList = [];
    for (j = 0, len = paramList.length; j < len; j++) {
      t = paramList[j];
      if (t.match(VAR_NAME_RE)) {
        vars.push(t + "_" + expression_default2.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));
      } else {
        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);
      }
    }
    switch (false) {
      case !isString2(transformations):
        transformationList.push(transformations);
        break;
      case !Array.isArray(transformations):
        resultArray = resultArray.concat(transformations);
    }
    transformationList = function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = transformationList.length; k < len1; k++) {
        value = transformationList[k];
        if (Array.isArray(value) && !isEmpty2(value) || !Array.isArray(value) && value) {
          results.push(value);
        }
      }
      return results;
    }();
    transformationList = vars.sort().concat(variables).concat(transformationList.sort());
    if (ifParam === "if_end") {
      transformationList.push(ifParam);
    } else if (!isEmpty2(ifParam)) {
      transformationList.unshift(ifParam);
    }
    transformationString = transformationList.filter((x) => !!x).join(param_separator);
    if (!isEmpty2(transformationString)) {
      resultArray.push(transformationString);
    }
    return resultArray.filter((x) => !!x).join(trans_separator);
  }
  /**
   * Provide a list of all the valid transformation option names
   * @function Transformation#listNames
   * @private
   * @return {Array<string>} a array of all the valid option names
   */
  static listNames() {
    return methods2;
  }
  /**
   * Returns the attributes for an HTML tag.
   * @function Cloudinary.toHtmlAttributes
   * @return PlainObject
   */
  toHtmlAttributes() {
    let attrName, height, options, ref2, ref3, value, width;
    options = {};
    let snakeCaseKey;
    Object.keys(this.otherOptions).forEach((key) => {
      value = this.otherOptions[key];
      snakeCaseKey = snakeCase2(key);
      if (!contains2(PARAM_NAMES2, snakeCaseKey) && !contains2(URL_KEYS, snakeCaseKey)) {
        attrName = /^html_/.test(key) ? key.slice(5) : key;
        options[attrName] = value;
      }
    });
    this.keys().forEach((key) => {
      if (/^html_/.test(key)) {
        options[camelCase2(key.slice(5))] = this.getValue(key);
      }
    });
    if (!(this.hasLayer() || this.getValue("angle") || contains2(["fit", "limit", "lfill"], this.getValue("crop")))) {
      width = (ref2 = this.get("width")) != null ? ref2.origValue : void 0;
      height = (ref3 = this.get("height")) != null ? ref3.origValue : void 0;
      if (parseFloat(width) >= 1) {
        if (options.width == null) {
          options.width = width;
        }
      }
      if (parseFloat(height) >= 1) {
        if (options.height == null) {
          options.height = height;
        }
      }
    }
    return options;
  }
  static isValidParamName(name2) {
    return methods2.indexOf(camelCase2(name2)) >= 0;
  }
  /**
   * Delegate to the parent (up the call chain) to produce HTML
   * @function Transformation#toHtml
   * @return {string} HTML representation of the parent if possible.
   * @example
   * tag = cloudinary.ImageTag.new("sample", {cloud_name: "demo"})
   * // ImageTag {name: "img", publicId: "sample"}
   * tag.toHtml()
   * // <img src="http://res.cloudinary.com/demo/image/upload/sample">
   * tag.transformation().crop("fit").width(300).toHtml()
   * // <img src="http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample">
   */
  toHtml() {
    var ref;
    return (ref = this.getParent()) != null ? typeof ref.toHtml === "function" ? ref.toHtml() : void 0 : void 0;
  }
  toString() {
    return this.serialize();
  }
  clone() {
    return new _TransformationBase(this.toOptions(true));
  }
};
var VAR_NAME_RE = /^\$[a-zA-Z0-9]+$/;
var trans_separator = "/";
var param_separator = ",";
function lastArgCallback(args) {
  var callback;
  callback = args != null ? args[args.length - 1] : void 0;
  if (isFunction4(callback)) {
    return callback;
  } else {
    return void 0;
  }
}
function processVar(varArray) {
  var j, len, name2, results, v;
  if (Array.isArray(varArray)) {
    results = [];
    for (j = 0, len = varArray.length; j < len; j++) {
      [name2, v] = varArray[j];
      results.push(`${name2}_${expression_default2.normalize(v)}`);
    }
    return results;
  } else {
    return varArray;
  }
}
function processCustomFunction3({ function_type, source: source2 }) {
  if (function_type === "remote") {
    return [function_type, btoa(source2)].join(":");
  } else if (function_type === "wasm") {
    return [function_type, source2].join(":");
  }
}
var Transformation2 = class _Transformation extends TransformationBase {
  /**
   * Represents a single transformation.
   * @class Transformation
   * @example
   * t = new cloudinary.Transformation();
   * t.angle(20).crop("scale").width("auto");
   *
   * // or
   *
   * t = new cloudinary.Transformation( {angle: 20, crop: "scale", width: "auto"});
   * @see <a href="https://cloudinary.com/documentation/image_transformation_reference"
   *  target="_blank">Available image transformations</a>
   * @see <a href="https://cloudinary.com/documentation/video_transformation_reference"
   *  target="_blank">Available video transformations</a>
   */
  constructor(options) {
    super(options);
  }
  /**
   * Convenience constructor
   * @param {Object} options
   * @return {Transformation}
   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: "scale", width: "auto"})
   */
  static new(options) {
    return new _Transformation(options);
  }
  /*
    Transformation Parameters
  */
  angle(value) {
    this.arrayParam(value, "angle", "a", ".", expression_default2.normalize);
    return this;
  }
  audioCodec(value) {
    this.param(value, "audio_codec", "ac");
    return this;
  }
  audioFrequency(value) {
    this.param(value, "audio_frequency", "af");
    return this;
  }
  aspectRatio(value) {
    this.param(value, "aspect_ratio", "ar", expression_default2.normalize);
    return this;
  }
  background(value) {
    this.param(value, "background", "b", Param.norm_color);
    return this;
  }
  bitRate(value) {
    this.param(value, "bit_rate", "br");
    return this;
  }
  border(value) {
    return this.param(value, "border", "bo", (border2) => {
      if (isObject5(border2)) {
        border2 = Object.assign({}, {
          color: "black",
          width: 2
        }, border2);
        return `${border2.width}px_solid_${Param.norm_color(border2.color)}`;
      } else {
        return border2;
      }
    });
  }
  color(value) {
    this.param(value, "color", "co", Param.norm_color);
    return this;
  }
  colorSpace(value) {
    this.param(value, "color_space", "cs");
    return this;
  }
  crop(value) {
    this.param(value, "crop", "c");
    return this;
  }
  customFunction(value) {
    return this.param(value, "custom_function", "fn", () => {
      return processCustomFunction3(value);
    });
  }
  customPreFunction(value) {
    if (this.get("custom_function")) {
      return;
    }
    return this.rawParam(value, "custom_function", "", () => {
      value = processCustomFunction3(value);
      return value ? `fn_pre:${value}` : value;
    });
  }
  defaultImage(value) {
    this.param(value, "default_image", "d");
    return this;
  }
  delay(value) {
    this.param(value, "delay", "dl");
    return this;
  }
  density(value) {
    this.param(value, "density", "dn");
    return this;
  }
  duration(value) {
    this.rangeParam(value, "duration", "du");
    return this;
  }
  dpr(value) {
    return this.param(value, "dpr", "dpr", (dpr2) => {
      dpr2 = dpr2.toString();
      if (dpr2 != null ? dpr2.match(/^\d+$/) : void 0) {
        return dpr2 + ".0";
      } else {
        return expression_default2.normalize(dpr2);
      }
    });
  }
  effect(value) {
    this.arrayParam(value, "effect", "e", ":", expression_default2.normalize);
    return this;
  }
  else() {
    return this.if("else");
  }
  endIf() {
    return this.if("end");
  }
  endOffset(value) {
    this.rangeParam(value, "end_offset", "eo");
    return this;
  }
  fallbackContent(value) {
    this.param(value, "fallback_content");
    return this;
  }
  fetchFormat(value) {
    this.param(value, "fetch_format", "f");
    return this;
  }
  format(value) {
    this.param(value, "format");
    return this;
  }
  flags(value) {
    this.arrayParam(value, "flags", "fl", ".");
    return this;
  }
  gravity(value) {
    this.param(value, "gravity", "g");
    return this;
  }
  fps(value) {
    return this.param(value, "fps", "fps", (fps2) => {
      if (isString2(fps2)) {
        return fps2;
      } else if (Array.isArray(fps2)) {
        return fps2.join("-");
      } else {
        return fps2;
      }
    });
  }
  height(value) {
    return this.param(value, "height", "h", () => {
      if (this.getValue("crop") || this.getValue("overlay") || this.getValue("underlay")) {
        return expression_default2.normalize(value);
      } else {
        return null;
      }
    });
  }
  htmlHeight(value) {
    this.param(value, "html_height");
    return this;
  }
  htmlWidth(value) {
    this.param(value, "html_width");
    return this;
  }
  if(value = "") {
    var i, ifVal, j, ref, trIf, trRest;
    switch (value) {
      case "else":
        this.chain();
        return this.param(value, "if", "if");
      case "end":
        this.chain();
        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {
          ifVal = this.chained[i].getValue("if");
          if (ifVal === "end") {
            break;
          } else if (ifVal != null) {
            trIf = _Transformation.new().if(ifVal);
            this.chained[i].remove("if");
            trRest = this.chained[i];
            this.chained[i] = _Transformation.new().transformation([trIf, trRest]);
            if (ifVal !== "else") {
              break;
            }
          }
        }
        return this.param(value, "if", "if");
      case "":
        return condition_default2.new().setParent(this);
      default:
        return this.param(value, "if", "if", (value2) => {
          return condition_default2.new(value2).toString();
        });
    }
  }
  keyframeInterval(value) {
    this.param(value, "keyframe_interval", "ki");
    return this;
  }
  ocr(value) {
    this.param(value, "ocr", "ocr");
    return this;
  }
  offset(value) {
    var end_o, start_o;
    [start_o, end_o] = isFunction4(value != null ? value.split : void 0) ? value.split("..") : Array.isArray(value) ? value : [null, null];
    if (start_o != null) {
      this.startOffset(start_o);
    }
    if (end_o != null) {
      return this.endOffset(end_o);
    }
  }
  opacity(value) {
    this.param(value, "opacity", "o", expression_default2.normalize);
    return this;
  }
  overlay(value) {
    this.layerParam(value, "overlay", "l");
    return this;
  }
  page(value) {
    this.param(value, "page", "pg");
    return this;
  }
  poster(value) {
    this.param(value, "poster");
    return this;
  }
  prefix(value) {
    this.param(value, "prefix", "p");
    return this;
  }
  quality(value) {
    this.param(value, "quality", "q", expression_default2.normalize);
    return this;
  }
  radius(value) {
    this.arrayParam(value, "radius", "r", ":", expression_default2.normalize);
    return this;
  }
  rawTransformation(value) {
    this.rawParam(value, "raw_transformation");
    return this;
  }
  size(value) {
    let height, width;
    if (isFunction4(value != null ? value.split : void 0)) {
      [width, height] = value.split("x");
      this.width(width);
      return this.height(height);
    }
  }
  sourceTypes(value) {
    this.param(value, "source_types");
    return this;
  }
  sourceTransformation(value) {
    return this.param(value, "source_transformation");
  }
  startOffset(value) {
    this.rangeParam(value, "start_offset", "so");
    return this;
  }
  streamingProfile(value) {
    this.param(value, "streaming_profile", "sp");
    return this;
  }
  transformation(value) {
    this.transformationParam(value, "transformation", "t");
    return this;
  }
  underlay(value) {
    this.layerParam(value, "underlay", "u");
    return this;
  }
  variable(name2, value) {
    this.param(value, name2, name2);
    return this;
  }
  variables(values) {
    this.arrayParam(values, "variables");
    return this;
  }
  videoCodec(value) {
    this.param(value, "video_codec", "vc", Param.process_video_params);
    return this;
  }
  videoSampling(value) {
    this.param(value, "video_sampling", "vs");
    return this;
  }
  width(value) {
    this.param(value, "width", "w", () => {
      if (this.getValue("crop") || this.getValue("overlay") || this.getValue("underlay")) {
        return expression_default2.normalize(value);
      } else {
        return null;
      }
    });
    return this;
  }
  x(value) {
    this.param(value, "x", "x", expression_default2.normalize);
    return this;
  }
  y(value) {
    this.param(value, "y", "y", expression_default2.normalize);
    return this;
  }
  zoom(value) {
    this.param(value, "zoom", "z", expression_default2.normalize);
    return this;
  }
};
var methods2 = [
  "angle",
  "audioCodec",
  "audioFrequency",
  "aspectRatio",
  "background",
  "bitRate",
  "border",
  "color",
  "colorSpace",
  "crop",
  "customFunction",
  "customPreFunction",
  "defaultImage",
  "delay",
  "density",
  "duration",
  "dpr",
  "effect",
  "else",
  "endIf",
  "endOffset",
  "fallbackContent",
  "fetchFormat",
  "format",
  "flags",
  "gravity",
  "fps",
  "height",
  "htmlHeight",
  "htmlWidth",
  "if",
  "keyframeInterval",
  "ocr",
  "offset",
  "opacity",
  "overlay",
  "page",
  "poster",
  "prefix",
  "quality",
  "radius",
  "rawTransformation",
  "size",
  "sourceTypes",
  "sourceTransformation",
  "startOffset",
  "streamingProfile",
  "transformation",
  "underlay",
  "variable",
  "variables",
  "videoCodec",
  "videoSampling",
  "width",
  "x",
  "y",
  "zoom"
];
var PARAM_NAMES2 = methods2.map(snakeCase2).concat(CONFIG_PARAMS2);
var transformation_default2 = Transformation2;

// node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processDpr.js
function processDpr2(value) {
  let dpr2 = value.toString();
  if (dpr2 != null ? dpr2.match(/^\d+$/) : void 0) {
    return dpr2 + ".0";
  } else {
    return expression_default2.normalize(dpr2);
  }
}

// node_modules/@cloudinary/url-gen/backwards/generateTransformationString.js
function generateTransformationString2(transformationOptions) {
  if (typeof transformationOptions === "string") {
    return transformationOptions;
  }
  if (transformationOptions instanceof transformation_default2) {
    return transformationOptions.toString();
  }
  if (Array.isArray(transformationOptions)) {
    return transformationOptions.map((singleTransformation) => {
      return generateTransformationString2(singleTransformation);
    }).filter((a) => {
      return a;
    }).join("/");
  }
  let width;
  let height;
  const size = transformationOptions.size;
  const hasLayer = transformationOptions.overlay || transformationOptions.underlay;
  const crop2 = transformationOptions.crop;
  const angle = toArray2(transformationOptions.angle).join(".");
  const background = (transformationOptions.background || "").replace(/^#/, "rgb:");
  const color2 = (transformationOptions.color || "").replace(/^#/, "rgb:");
  const flags = toArray2(transformationOptions.flags || []).join(".");
  const dpr2 = transformationOptions.dpr === void 0 ? transformationOptions.dpr : processDpr2(transformationOptions.dpr);
  const overlay = processLayer2(transformationOptions.overlay);
  const radius = processRadius2(transformationOptions.radius);
  const underlay = processLayer2(transformationOptions.underlay);
  const ifValue = process_if2(transformationOptions.if);
  const custom_function = processCustomFunction2(transformationOptions.custom_function);
  const custom_pre_function = processCustomPreFunction2(transformationOptions.custom_pre_function);
  let fps2 = transformationOptions.fps;
  let namedTransformations = [];
  let childTransformations = toArray2(transformationOptions.transformation || []);
  let effect = transformationOptions.effect;
  const no_html_sizes = hasLayer || angle || crop2 === "fit" || crop2 === "limit";
  if (size) {
    const [sizeWidth, sizeHeight] = size.split("x");
    width = sizeWidth;
    height = sizeHeight;
  } else {
    width = transformationOptions.width;
    height = transformationOptions.height;
  }
  if (width && (width.toString().indexOf("auto") === 0 || no_html_sizes || parseFloat(width.toString()) < 1)) {
    delete transformationOptions.width;
  }
  if (height && (no_html_sizes || parseFloat(height.toString()) < 1)) {
    delete transformationOptions.height;
  }
  const isAnyChildAnObject = childTransformations.some((transformation) => typeof transformation === "object");
  if (isAnyChildAnObject) {
    childTransformations = childTransformations.map((transformation) => {
      if (isObject5(transformation)) {
        return generateTransformationString2(transformation);
      } else {
        return generateTransformationString2({ transformation });
      }
    }).filter((a) => a);
  } else {
    namedTransformations = childTransformations.join(".");
    childTransformations = [];
  }
  if (Array.isArray(effect)) {
    effect = effect.join(":");
  } else if (isObject5(effect)) {
    effect = Object.entries(effect).map(([key, value]) => `${key}:${value}`);
  }
  let border2 = transformationOptions.border;
  if (isObject5(border2)) {
    border2 = `${border2.width != null ? border2.width : 2}px_solid_${(border2.color != null ? border2.color : "black").replace(/^#/, "rgb:")}`;
  } else {
    if (/^\d+$/.exec(border2)) {
      transformationOptions.border = border2;
      border2 = void 0;
    }
  }
  if (Array.isArray(fps2)) {
    fps2 = fps2.join("-");
  }
  const urlParams = {
    a: legacyNormalizeExpression2(angle),
    ar: legacyNormalizeExpression2(transformationOptions.aspect_ratio),
    b: background,
    bo: border2,
    c: crop2,
    co: color2,
    dpr: legacyNormalizeExpression2(dpr2),
    e: legacyNormalizeExpression2(effect),
    fl: flags,
    fn: custom_function || custom_pre_function,
    fps: fps2,
    h: legacyNormalizeExpression2(height),
    ki: legacyNormalizeExpression2(transformationOptions.keyframe_interval),
    l: overlay,
    o: legacyNormalizeExpression2(transformationOptions.opacity),
    q: legacyNormalizeExpression2(transformationOptions.quality),
    r: radius,
    t: namedTransformations,
    u: underlay,
    w: legacyNormalizeExpression2(width),
    x: legacyNormalizeExpression2(transformationOptions.x),
    y: legacyNormalizeExpression2(transformationOptions.y),
    z: legacyNormalizeExpression2(transformationOptions.zoom),
    ac: transformationOptions.audio_codec,
    af: transformationOptions.audio_frequency,
    br: transformationOptions.bit_rate,
    cs: transformationOptions.color_space,
    d: transformationOptions.default_image,
    dl: transformationOptions.delay,
    dn: transformationOptions.density,
    du: normRangeValues2(transformationOptions.duration),
    eo: normRangeValues2(transformationOptions.end_offset || isNumberLike2(transformationOptions.end_offset) ? transformationOptions.end_offset : splitRange2(transformationOptions.offset)[1]),
    f: transformationOptions.fetch_format,
    g: transformationOptions.gravity,
    pg: transformationOptions.page,
    p: transformationOptions.prefix,
    so: normRangeValues2(transformationOptions.start_offset || isNumberLike2(transformationOptions.start_offset) ? transformationOptions.start_offset : splitRange2(transformationOptions.offset)[0]),
    sp: transformationOptions.streaming_profile,
    vc: processVideoParams2(transformationOptions.video_codec),
    vs: transformationOptions.video_sampling
  };
  const variables = Object.entries(transformationOptions).filter(([key, value]) => key.startsWith("$")).map(([key, value]) => {
    return `${key}_${legacyNormalizeExpression2(value)}`;
  }).sort().concat(
    // @ts-ignore
    (transformationOptions.variables || []).map(([name2, value]) => `${name2}_${legacyNormalizeExpression2(value)}`)
  ).join(",");
  const urlImageTransfomrations = Object.entries(urlParams).filter(([key, value]) => {
    if (typeof value === "undefined" || value === null) {
      return false;
    }
    if (typeof value === "string" && value.length === 0) {
      return false;
    }
    if (Array.isArray(value) && value.length === 0) {
      return false;
    }
    return true;
  }).map(([key, value]) => `${key}_${value}`).sort().join(",");
  const finalTransformationString = [
    ifValue,
    variables,
    urlImageTransfomrations,
    transformationOptions.raw_transformation
  ].filter((a) => a).join(",");
  if (finalTransformationString) {
    childTransformations.push(finalTransformationString);
  }
  return childTransformations.join("/");
}
var transformationStringFromObject = generateTransformationString2;

// node_modules/@cloudinary/url-gen/backwards/utils/finalizeResourceType.js
function finalize_resource_type2(resource_type, type, url_suffix, use_root_path, shorten) {
  if (type == null) {
    type = "upload";
  }
  if (url_suffix != null) {
    if (resource_type === "image" && type === "upload") {
      resource_type = "images";
      type = null;
    } else if (resource_type === "image" && type === "private") {
      resource_type = "private_images";
      type = null;
    } else if (resource_type === "image" && type === "authenticated") {
      resource_type = "authenticated_images";
      type = null;
    } else if (resource_type === "raw" && type === "upload") {
      resource_type = "files";
      type = null;
    } else if (resource_type === "video" && type === "upload") {
      resource_type = "videos";
      type = null;
    } else {
      throw new Error("URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload");
    }
  }
  if (use_root_path) {
    if (resource_type === "image" && type === "upload" || resource_type === "images" && type == null) {
      resource_type = null;
      type = null;
    } else {
      throw new Error("Root path only supported for image/upload");
    }
  }
  if (shorten && resource_type === "image" && type === "upload") {
    resource_type = "iu";
    type = null;
  }
  return [resource_type, type];
}

// node_modules/@cloudinary/url-gen/backwards/utils/finalize_source.js
function finalize_source2(source2, format2, url_suffix) {
  let source_to_sign;
  source2 = source2.replace(/([^:])\/\//g, "$1/");
  if (source2.match(/^https?:\//i)) {
    source2 = smartEscape2(source2);
    source_to_sign = source2;
  } else {
    source2 = encodeURIComponent(decodeURIComponent(source2)).replace(/%3A/g, ":").replace(/%2F/g, "/");
    source_to_sign = source2;
    if (url_suffix) {
      if (url_suffix.match(/[\.\/]/)) {
        throw new Error("url_suffix should not include . or /");
      }
      source2 = source2 + "/" + url_suffix;
    }
    if (format2 != null) {
      source2 = source2 + "." + format2;
      source_to_sign = source_to_sign + "." + format2;
    }
  }
  return [source2, source_to_sign];
}

// node_modules/@cloudinary/url-gen/backwards/utils/unsigned_url_prefix.js
function unsigned_url_prefix2(source2, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
  let prefix;
  if (cloud_name.indexOf("/") === 0) {
    return "/res" + cloud_name;
  }
  let shared_domain = !private_cdn;
  if (secure) {
    if (secure_distribution == null || secure_distribution === OLD_AKAMAI_SHARED_CDN2) {
      secure_distribution = private_cdn ? cloud_name + "-res.cloudinary.com" : SHARED_CDN2;
    }
    if (shared_domain == null) {
      shared_domain = secure_distribution === SHARED_CDN2;
    }
    prefix = "https://" + secure_distribution;
  } else if (cname) {
    prefix = "http://" + cname;
  } else {
    let cdn_part = private_cdn ? cloud_name + "-" : "";
    let host = [cdn_part, "res", ".cloudinary.com"].join("");
    prefix = "http://" + host;
  }
  if (shared_domain) {
    prefix += "/" + cloud_name;
  }
  return prefix;
}

// node_modules/@cloudinary/url-gen/backwards/createCloudinaryLegacyURL.js
function createCloudinaryLegacyURL2(public_id, transformationOptions) {
  if (transformationOptions.type === "fetch") {
    if (transformationOptions.fetch_format == null) {
      transformationOptions.fetch_format = transformationOptions.format;
    }
  }
  let source_to_sign;
  let type = transformationOptions.type;
  let resource_type = transformationOptions.resource_type || "image";
  let version = transformationOptions.version;
  const force_version = typeof transformationOptions.force_version === "boolean" ? transformationOptions.force_version : true;
  const long_url_signature = !!transformationOptions.long_url_signature;
  const format2 = transformationOptions.format;
  const cloud_name = transformationOptions.cloud_name;
  if (!cloud_name) {
    throw "cloud_name must be provided in the configuration";
  }
  const private_cdn = transformationOptions.private_cdn;
  const secure_distribution = transformationOptions.secure_distribution;
  const secure = transformationOptions.secure;
  const cdn_subdomain = transformationOptions.cdn_subdomain;
  const secure_cdn_subdomain = transformationOptions.secure_cdn_subdomain;
  const cname = transformationOptions.cname;
  const shorten = transformationOptions.shorten;
  const sign_url = transformationOptions.sign_url;
  const api_secret = transformationOptions.api_secret;
  const url_suffix = transformationOptions.url_suffix;
  const use_root_path = transformationOptions.use_root_path;
  const auth_token = transformationOptions.auth_token;
  const preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
  if (preloaded) {
    resource_type = preloaded[1];
    type = preloaded[2];
    version = preloaded[3];
    public_id = preloaded[4];
  }
  const original_source = public_id;
  if (public_id == null) {
    return original_source;
  }
  public_id = public_id.toString();
  if (type === null && public_id.match(/^https?:\//i)) {
    return original_source;
  }
  [resource_type, type] = finalize_resource_type2(resource_type, type, url_suffix, use_root_path, shorten);
  [public_id, source_to_sign] = finalize_source2(public_id, format2, url_suffix);
  if (version == null && force_version && source_to_sign.indexOf("/") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
    version = 1;
  }
  if (version != null) {
    version = `v${version}`;
  } else {
    version = null;
  }
  const transformation = generateTransformationString2(cloneDeep2(transformationOptions)).replace(/([^:])\/\//g, "$1/");
  ;
  if (sign_url && !auth_token) {
    let to_sign = [transformation, source_to_sign].filter(function(part) {
      return part != null && part !== "";
    }).join("/");
    try {
      for (let i = 0; to_sign !== decodeURIComponent(to_sign) && i < 10; i++) {
        to_sign = decodeURIComponent(to_sign);
      }
    } catch (error) {
    }
  }
  const prefix = unsigned_url_prefix2(public_id, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
  const resultUrl = [prefix, resource_type, type, transformation, version, public_id].filter(function(part) {
    return part != null && part !== "";
  }).join("/").replace(" ", "%20");
  return resultUrl;
}

// node_modules/@cloudinary/url-gen/actions.js
var actions_exports2 = {};
__export(actions_exports2, {
  Adjust: () => Adjust,
  Animated: () => Animated,
  Border: () => Border,
  CustomFunction: () => CustomFunction,
  Delivery: () => Delivery,
  Effect: () => Effect,
  NamedTransformation: () => NamedTransformation,
  Overlay: () => Overlay,
  PSDTools: () => PSDTools,
  Resize: () => Resize,
  Rotate: () => Rotate,
  RoundCorners: () => RoundCorners,
  Transcode: () => Transcode,
  Underlay: () => Underlay,
  VideoEdit: () => VideoEdit
});
export {
  actions_exports2 as Actions,
  CloudConfig_default as CloudConfig,
  Cloudinary,
  CloudinaryConfig_default as CloudinaryConfig,
  CloudinaryFile,
  CloudinaryImage,
  CloudinaryMedia,
  CloudinaryVideo,
  ImageTransformation,
  qualifiers_exports as Qualifiers,
  Transformation,
  URLConfig_default as URLConfig,
  VideoTransformation,
  createCloudinaryLegacyURL2 as createCloudinaryLegacyURL,
  transformationStringFromObject
};
//# sourceMappingURL=@cloudinary_url-gen.js.map
